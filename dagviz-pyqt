#!/usr/bin/python3

import sys, os, random

#from PyQt5.QtGui import QIcon, QFont
#from PyQt5.QtWidgets import QApplication, QWidget, QToolTip, QPushButton
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

import sip
sysroot = os.path.dirname(os.path.realpath(sys.argv[0]))
sys.path.append(sysroot + "/sip")
import dagrenderer

GO = {
    "zoom_rate_per_time" : 0.08,   # rate per scrolling time
    "zoom_rate_per_pixel" : 0.004, # rate per scrolling pixel: 0.08 / 20
    "zoom_default_weight" : 20,    # rate in pixel unit on one default zoom
    "margin_top"    : 10,
    "margin_bottom" : 10,
    "margin_left"   : 10,
    "margin_right"  : 10,
    "moving_distance" : 25.0,      # pixels, moving distance when pressing arrow keys
    "moving_distance_rate" : 20.0, # times, multiplied rate with modifier keys (Ctrl > Alt)
    "auto_zoom_fit" : 1, # automatically zoom to fit at the beginning: 0->none, 1->full, 2->hor, 3->ver
    "scaling_radix_scrolling_rate": 0.004, # rate for adjusting scaling radix at each scrolling
}

renderers = []

class Marker(QWidget):
    def __init__(self):
        super(Marker, self).__init__()
    def enable(self):
        self.color = "red"
        self.update()
    def disable(self):
        self.color = "white"
        self.update()
    def paintEvent(self, e):
        qp = QPainter(self)
        qp.fillRect(0, 0, self.width(), self.height(), QColor(self.color))
        

class ScrollBar(QSlider):
    def __init__(self, o):
        super(ScrollBar, self).__init__(o)
        self.length = 100
        self.color = "grey"
        #self.setTracking(True)
        self.setTracking(False)
        self.valueChanged.connect(self.doValueChanged)
        self.setSingleStep(1)
        self.setPageStep(20)        
        self.resetStyle()
        
    def resetStyle(self):
        if self.orientation() == Qt.Horizontal:
            self.setStyleSheet("""
QSlider::groove:horizontal {
    border: none;
    background: white;
    height: 4px;
}
QSlider:horizontal {
    height: 4px;
    margin: 0px 0px 0px 0px;
}
QSlider::handle:horizontal {
    background: solid %s;
    width: %i px;
}
        """ % (self.color, self.length))
        else:
            self.setStyleSheet("""
QSlider::groove:vertical {
    border: none;
    background: white;
    width: 4px;
}
QSlider:vertical {
    width: 4px;
    margin: 0px 0px 0px 0px;
}
QSlider::handle:vertical {
    background: solid %s;
    height: %i px;
}
        """ % (self.color, self.length))
        
    def setLength(self, l):
        self.length = l
        self.resetStyle()

    def doValueChanged(self, v):
        #print(v)
        #print(self.value())
        None

    def adjust(self, w, d1, d2, v1, v2):
        a = 0 # min value
        b = w # max value
        p = 0 # current value
        l = w # handle's length 
        if d2 - d1 > v2 - v1:
            self.color = "black"
            left = d1
            right = d2 - (v2 - v1)
            a = 0
            b = w * (right - left) / (d2 - d1)
            p = (v1 - left) / (right - left) * (b - a)
            l = (v2 - v1) / (right - left) * (b - a)
            if p < a:
                l -= a - p
            if p > b:
                l -= p - b
        elif v2 - v1 > d2 - d1:
            self.color = "grey"
            left = v1
            right = v2 - (d2 - d1)
            a = 0
            b = w * (right - left) / (v2 - v1)
            p = (d1 - left) / (right - left) * (b - a)
            l = (d2 - d1) / (right - left) * (b - a)
            if p < a:
                l -= a - p
            if p > b:
                l -= p - b
        # else:
        #     if v1 > d1:
        #         b = (v1 - d1) / (d2 - d1) * w
        #         p = b
        #         l = w - b
        #     elif v2 < d2:
        #         l -= (d2 - v2) / (d2 - d1) * (b - a)
        if l < 3:
            l = 3
        self.setMinimum(a)
        self.setMaximum(b)
        self.setValue(p)
        self.setLength(l)
        

class Viewport(QWidget):
    def __init__(self, W, R, lt):
        super(Viewport, self).__init__()
        self.W = W
        self.R = R
        self.base_x = 0.0
        self.base_y = 0.0
        self.currentLayout = lt
        self.switch_layout_to(self.currentLayout)
        # container with scroll bars
        self.verScrollBar = ScrollBar(Qt.Vertical)
        self.verScrollBar.setRange(0, 0)
        self.verScrollBar.setValue(0)
        self.verScrollBar.setLength(0)
        self.horScrollBar = ScrollBar(Qt.Horizontal)
        self.horScrollBar.setRange(0, 0)
        self.horScrollBar.setValue(0)
        self.horScrollBar.setLength(0)
        self.marker = Marker()
        self.marker.disable()
        # hbox = QHBoxLayout()
        # hbox.setContentsMargins(0, 0, 0, 0)
        # hbox.setSpacing(0)
        # hbox.addWidget(self, 1)
        # hbox.addWidget(self.verScrollBar, 0)
        # vbox = QVBoxLayout()
        # vbox.setContentsMargins(0, 0, 0, 0)
        # vbox.setSpacing(0)
        # vbox.addLayout(hbox, 1)
        # hbox = QHBoxLayout()
        # hbox.setContentsMargins(0, 0, 0, 0)
        # hbox.setSpacing(0)
        # hbox.addWidget(self.horScrollBar, 1)
        # hbox.addWidget(self.verScrollBar, 0)        
        # vbox.addLayout(hbox, 0)
        # self.containerWithScrollBars = QWidget()
        # self.containerWithScrollBars.setLayout(vbox)
        grid = QGridLayout()
        grid.setContentsMargins(0, 0, 0, 0)
        grid.setSpacing(0)
        grid.addWidget(self, 0, 0)
        grid.addWidget(self.verScrollBar, 0, 1)
        grid.addWidget(self.horScrollBar, 1, 0)
        grid.addWidget(self.marker, 1, 1)
        self.containerWithScrollBars = QWidget()
        self.containerWithScrollBars.setLayout(grid)
        
        # background color
        pal = self.palette()
        pal.setColor(QPalette.Window, Qt.white)
        self.setPalette(pal)
        self.setAutoFillBackground(True)
        self.x = 0.0
        self.y = 0.0
        self.pan_on = False
        self.x_mouse_pressed = 0
        self.y_mouse_pressed = 0
        self.mouseCenteredExpansion = False
        self.x_mouse = 0
        self.y_mouse = 0
        self.setMouseTracking(True)
        self.R = R
        self.zoom_ratio_x = 1.0
        self.zoom_ratio_y = 1.0
        self.width
        # node context menu
        self.node_cmenu = QMenu(self)
        self.nodeExpandAct = self.node_cmenu.addAction("E&xpand node one depth")
        self.nodeCollapseAct = self.node_cmenu.addAction("&Collapse parent node one depth")
        self.nodeHighlightAct = self.node_cmenu.addAction("Switch node &highlight")
        self.node_cmenu.addSeparator()
        # default action when clicked
        clickedActMenu = self.node_cmenu.addMenu("&Default action when clicked")
        self.nodeClickedActGroup = QActionGroup(clickedActMenu)
        self.nodeClickedActGroup.setExclusive(True)
        self.nodeExpandActDef = clickedActMenu.addAction("E&xpand node one depth")
        self.nodeExpandActDef.setCheckable(True)
        self.nodeClickedActGroup.addAction(self.nodeExpandActDef)
        self.nodeCollapseActDef = clickedActMenu.addAction("&Collapse parent node one depth")
        self.nodeCollapseActDef.setCheckable(True)
        self.nodeClickedActGroup.addAction(self.nodeCollapseActDef)
        self.clickedNoneActDef = clickedActMenu.addAction("&None")
        self.clickedNoneActDef.setCheckable(True)
        self.nodeClickedActGroup.addAction(self.clickedNoneActDef)
        self.nodeExpandActDef.setChecked(True)
        # default action when hovered
        hoveredActMenu = self.node_cmenu.addMenu("&Default action when hovered")
        self.nodeHoveredActGroup = QActionGroup(hoveredActMenu)
        self.nodeHoveredActGroup.setExclusive(False)
        self.nodeInfoTooltipActDef = hoveredActMenu.addAction("Show node &information tooltip")
        self.nodeInfoTooltipActDef.setCheckable(True)
        self.nodeHoveredActGroup.addAction(self.nodeInfoTooltipActDef)
        self.nodeHighlightActDef = hoveredActMenu.addAction("&Highlight node")
        self.nodeHighlightActDef.setCheckable(True)
        self.nodeHighlightActDef.setChecked(True)
        self.nodeHoveredActGroup.addAction(self.nodeHighlightActDef)
        self.nodeInfoTooltipActDef.setChecked(True)
        self.highlightedHoveredNode = None

    def adjustScrollBars(self):
        # DAG: d1->d2, viewport: v1->v2 in DAG space
        d1 = - self.R.left_width(self.currentLayout)
        d2 = self.R.right_width(self.currentLayout)
        v1 = self.convert_x_to_dag_space(0)
        v2 = self.convert_x_to_dag_space(self.width())
        self.horScrollBar.adjust(self.width(), d1, d2, v1, v2)
        # DAG: d1->d2, viewport: v1->v2 in DAG space
        d1 = - self.R.down_height(self.currentLayout)
        d2 = self.R.up_height(self.currentLayout)
        v1 = - self.convert_y_to_dag_space(self.height())
        v2 = - self.convert_y_to_dag_space(0)
        self.verScrollBar.adjust(self.height(), d1, d2, v1, v2)
        
    def resetBaseXY(self):
        if self.currentLayout in {self.R.LAYOUT_TYPE_1, self.R.LAYOUT_TYPE_2, self.R.LAYOUT_TYPE_3, self.R.LAYOUT_TYPE_4}:
            self.base_x = GO["margin_left"] + (self.width() - GO["margin_left"] - GO["margin_right"]) / 2.0
            self.base_y = GO["margin_top"]
        elif self.currentLayout == self.R.LAYOUT_TYPE_5:
            self.base_x = GO["margin_left"]
            self.base_y = self.height() - GO["margin_bottom"]
        else:
            print("[Error]: unknown current layout")

    def resizeEvent(self, e):
        # adjust base_x, base_y
        self.resetBaseXY()

    def update(self):
        super(Viewport, self).update()

    def convert_x_to_dag_space(self, x):
        return (x - self.x - self.base_x) / self.zoom_ratio_x
    def convert_y_to_dag_space(self, y):
        return (y - self.y - self.base_y) / self.zoom_ratio_y
    def convert_x_from_dag_space(self, x):
        return x * self.zoom_ratio_x + self.x + self.base_x
    def convert_y_from_dag_space(self, y):
        return y * self.zoom_ratio_y + self.y + self.base_y
    def convert_dx_from_dag_space(self, dx):
        return dx * self.zoom_ratio_x
    def convert_dy_from_dag_space(self, dy):
        return dy * self.zoom_ratio_y
        
    def paintEvent(self, e):
        # adjusted deltas from Renderer
        Rdx = self.convert_dx_from_dag_space(self.R.getDx())
        Rdy = self.convert_dy_from_dag_space(self.R.getDy())
        self.x += Rdx
        self.y += Rdy
        # auto zoom fit
        if GO["auto_zoom_fit"] == 1:
            self.do_zoom_fit_full_auto()
        elif GO["auto_zoom_fit"] == 2:
            self.do_zoom_fit_hor_auto()
        elif GO["auto_zoom_fit"] == 3:
            self.do_zoom_fit_ver_auto()
        qp = QPainter(self)
        qp.translate(self.base_x, self.base_y)
        qp.translate(self.x, self.y)
        qp.scale(self.zoom_ratio_x, self.zoom_ratio_y)
        if self.R is not None:
            if (self.mouseCenteredExpansion):
                self.R.draw(sip.unwrapinstance(qp),
                            self.convert_x_to_dag_space(self.x_mouse),
                            self.convert_y_to_dag_space(self.y_mouse))
            else:
                self.R.draw(sip.unwrapinstance(qp))
        # adjust scrollbars
        self.adjustScrollBars()

    def do_moving(self, dx, dy):
        self.x = self.x + dx
        self.y = self.y + dy
        GO["auto_zoom_fit"] = False
        self.update()

    def do_zooming(self, x, y, weight):
        if weight != 0:
            new_zx = self.zoom_ratio_x
            new_zy = self.zoom_ratio_y
            factor = 1 + GO["zoom_rate_per_pixel"] * abs(weight)
            if weight > 0:
                new_zx *= factor
                new_zy *= factor
            else:
                new_zx /= factor
                new_zy /= factor
            x_dag = self.convert_x_to_dag_space(x)
            y_dag = self.convert_y_to_dag_space(y)
            self.zoom_ratio_x = new_zx
            self.zoom_ratio_y = new_zy
            new_x = self.convert_x_from_dag_space(x_dag)
            new_y = self.convert_y_from_dag_space(y_dag)
            dx = new_x - x
            dy = new_y - y
            self.x -= dx
            self.y -= dy
            GO["auto_zoom_fit"] = False
            self.update()
        
    def change_dag_scaling_factor(self, weight):
        if weight != 0:
            if self.currentLayout == self.R.LAYOUT_TYPE_2 or self.R.LAYOUT_TYPE_3 or self.R.LAYOUT_TYPE_4 or self.R.LAYOUT_TYPE_5:
                if self.currentLayout == self.R.LAYOUT_TYPE_2 or self.R.LAYOUT_TYPE_5:
                    radix = self.R.getLinearRadix();
                elif self.currentLayout == self.R.LAYOUT_TYPE_3:
                    radix = self.R.getPowerRadix();
                elif self.currentLayout == self.R.LAYOUT_TYPE_4:
                    radix = self.R.getLogRadix();
                factor = 1 + GO["scaling_radix_scrolling_rate"] * abs(weight)
                if weight > 0:
                    radix *= factor
                else:
                    radix /= factor
                if self.currentLayout == self.R.LAYOUT_TYPE_2 or self.R.LAYOUT_TYPE_5:
                    self.R.setLinearRadix(radix);
                elif self.currentLayout == self.R.LAYOUT_TYPE_3:
                    self.R.setPowerRadix(radix);
                elif self.currentLayout == self.R.LAYOUT_TYPE_4:
                    self.R.setLogRadix(radix);
                self.R.layout(self.currentLayout)
                self.update()
        
    def wheelEvent(self, e):
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            # moving
            self.do_moving(e.pixelDelta().x(), e.pixelDelta().y())
        elif mod == Qt.ShiftModifier:
            # scrolling scaling factor
            if self.W.adjustScalingFactorEnabled:
                weight = e.pixelDelta().y()
                self.change_dag_scaling_factor(weight)
        else:
            # zooming
            weight = e.pixelDelta().y()
            self.do_zooming(e.x(), e.y(), weight)
        self.update()

    def mousePressEvent(self, e):
        # grab focus
        self.W.setFocusedViewport(self)
        # only detect LeftButton (RightButton triggers context menus)
        if e.button() == Qt.LeftButton:
            # pan 
            self.x_mouse_pressed = e.x()
            self.y_mouse_pressed = e.y()
            self.pan_on = True
    def mouseReleaseEvent(self, e):
        # only detect LeftButton (RightButton triggers context menus)
        if e.button() == Qt.LeftButton:
            # pan
            self.pan_on = False
            # node clicked
            checkedAction = self.nodeClickedActGroup.checkedAction()
            if checkedAction != self.clickedNoneActDef:            
                x_dag = self.convert_x_to_dag_space(e.x())
                y_dag = self.convert_y_to_dag_space(e.y())
                node = self.R.find_node(x_dag, y_dag, self.currentLayout)
                if node is not None:
                    if checkedAction == self.nodeExpandActDef:
                        self.R.do_expanding_one_r(node)
                    elif checkedAction == self.nodeCollapseActDef:
                        self.R.do_collapsing_parent(node)
                    if self.R.animationOn == 0:
                        self.R.layout()
                        self.update()                    

    def enterEvent(self, e):
        self.mouseCenteredExpansion = True
        None
        
    def leaveEvent(self, e):
        self.mouseCenteredExpansion = False
        None
        
    def mouseMoveEvent(self, e):
        self.x_mouse = e.x()
        self.y_mouse = e.y()
        if self.pan_on:
            self.x += e.x() - self.x_mouse_pressed
            self.y += e.y() - self.y_mouse_pressed
            self.x_mouse_pressed = e.x()
            self.y_mouse_pressed = e.y()
            GO["auto_zoom_fit"] = False
            self.update()
        else:
            # node hovered
            checkedAction = self.nodeHoveredActGroup.checkedAction()
            if checkedAction is not None:
                x_dag = self.convert_x_to_dag_space(e.x())
                y_dag = self.convert_y_to_dag_space(e.y())
                node = self.R.find_node(x_dag, y_dag, self.currentLayout)
                if node is not None:
                    if self.nodeInfoTooltipActDef.isChecked():
                        info_dict = self.R.get_dag_node_info(node)
                        info_str = self.get_node_info_string(info_dict)
                        QToolTip.showText(e.globalPos(), info_str, self, QRect(), 30000)
                    if self.nodeHighlightActDef.isChecked():
                        if self.R.node_is_highlighted(node) == 0:
                            self.highlightedHoveredNode = node
                            self.R.highlight_node(node)
                            self.R.update()
                else:
                    if self.nodeInfoTooltipActDef.isChecked:
                        QToolTip.showText(e.globalPos(), None, self)
                    if self.nodeHighlightActDef.isChecked():
                        if self.highlightedHoveredNode is not None:
                            self.R.unhighlight_node(self.highlightedHoveredNode)
                            self.highlightedHoveredNode = None
                            self.R.update()

    def get_node_info_string(self, d):
        s = ("[Node %i]\n"
             "worker %i, CPU %i, node kind %i\n"
             "  t_1 (work): %i\n"
             "t_inf (span): %i\n"
             "earliest start time: %i\n"
             "    first ready time: %i\n"
             "       last start time: %i\n"
             "start: t=%i, worker %i, CPU %i (%s:%i)\n"
             "  end: t=%i, worker %i, CPU %i (%s:%i)\n"
             "counters=%s") % (
                 d["node_id"],
                 d["worker"], d["cpu"], d["kind"],
                 d["t_1"], d["t_inf"],
                 d["est"], d["first_ready_t"], d["last_start_t"],
                 d["start"][0], d["start"][1], d["start"][2], d["start"][3], d["start"][4],
                 d["end"][0], d["end"][1], d["end"][2], d["end"][3], d["end"][4],
                 d["counters"])
        return s

    def move_up(self):
        dx = 0.0
        dy = GO["moving_distance"]
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
    def move_down(self):
        dx = 0.0
        dy = - GO["moving_distance"]
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
    def move_left(self):
        dx = GO["moving_distance"]
        dy = 0.0
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
    def move_right(self):
        dx = - GO["moving_distance"]
        dy = 0.0
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
        
    def do_zoom_in(self):
        self.do_zooming(self.width() / 2, self.height() / 2, GO["zoom_default_weight"])
        
    def do_zoom_out(self):
        self.do_zooming(self.width() / 2, self.height() / 2, - GO["zoom_default_weight"])

    def get_zoom_fit_hor_attributes(self):
        x = 0.0
        y = 0.0
        z = 1.0
        if self.R == None:
            return x,y,z
        w1 = self.R.width(self.currentLayout)
        w2 = self.width() - GO["margin_left"] - GO["margin_right"]
        if w1 > w2:
            z = w2 / w1
        if self.currentLayout in {self.R.LAYOUT_TYPE_1, self.R.LAYOUT_TYPE_2, self.R.LAYOUT_TYPE_3, self.R.LAYOUT_TYPE_4}:
            x -= z * (self.R.right_width(self.currentLayout) - self.R.left_width(self.currentLayout)) / 2
        elif self.currentLayout == self.R.LAYOUT_TYPE_5:
            y -= z * self.R.down_height(self.currentLayout)
            dy = (self.height() - GO["margin_bottom"] - z * self.R.height(self.currentLayout) ) / 2.0;
            if dy > 0:
                y -= dy;
        else:
            print("[Error]: unknown current layout")
        return x,y,z
    def do_zoom_fit_hor_auto(self):
        x,y,z = self.get_zoom_fit_hor_attributes()
        self.x = x
        self.y = y
        self.zoom_ratio_x = z
        self.zoom_ratio_y = z
    def do_zoom_fit_hor(self):
        self.do_zoom_fit_hor_auto()
        GO["auto_zoom_fit"] = 2
        self.update()
            
    def get_zoom_fit_ver_attributes(self):
        x = 0.0
        y = 0.0
        z = 1.0
        if self.R == None:
            return x,y,z
        h1 = self.R.height(self.currentLayout)
        h2 = self.height() - GO["margin_top"] - GO["margin_bottom"]
        if h1 > h2:
            z = h2 / h1
        if self.currentLayout in {self.R.LAYOUT_TYPE_1, self.R.LAYOUT_TYPE_2, self.R.LAYOUT_TYPE_3, self.R.LAYOUT_TYPE_4}:
            x -= z * (self.R.right_width(self.currentLayout) - self.R.left_width(self.currentLayout)) / 2
        elif self.currentLayout == self.R.LAYOUT_TYPE_5:
            y -= z * self.R.down_height(self.currentLayout)
            dx = (self.width() - GO["margin_top"] - GO["margin_bottom"] - z * self.R.width(self.currentLayout)) / 2.0;
            if dx > 0:
                x += dx;
        else:
            print("[Error]: unknown current layout")
        return x,y,z
        
    def do_zoom_fit_ver_auto(self):
        x,y,z = self.get_zoom_fit_ver_attributes()
        self.x = x
        self.y = y
        self.zoom_ratio_x = z
        self.zoom_ratio_y = z
    def do_zoom_fit_ver(self):
        self.do_zoom_fit_ver_auto()
        GO["auto_zoom_fit"] = 3
        self.update()
        
    def do_zoom_fit_full_auto(self):
        x1,y1,z1 = self.get_zoom_fit_hor_attributes()
        x2,y2,z2 = self.get_zoom_fit_ver_attributes()
        if z1 < z2:
            self.x = x1
            self.y = y1
            self.zoom_ratio_x = z1
            self.zoom_ratio_y = z1
        else:
            self.x = x2
            self.y = y2
            self.zoom_ratio_x = z2
            self.zoom_ratio_y = z2
    def do_zoom_fit_full(self):
        self.do_zoom_fit_full_auto()
        GO["auto_zoom_fit"] = 1
        self.update()
        
    def do_expanding_one(self):
        if self.R is not None:
            self.R.do_expanding_one()
            if self.R.animationOn == 0:
                self.R.layout()
                self.update()
    
    def do_collapsing_one(self):
        if self.R is not None:
            self.R.do_collapsing_one()
            if self.R.animationOn == 0:
                self.R.layout()
                self.update()

    def contextMenuEvent(self, e):
        x_dag = self.convert_x_to_dag_space(e.x())
        y_dag = self.convert_y_to_dag_space(e.y())
        node = self.R.find_node(x_dag, y_dag, self.currentLayout)
        if node is not None:
            cmenu = self.node_cmenu
            action = cmenu.exec_(self.mapToGlobal(e.pos()))
            if action == self.nodeExpandAct or action == self.nodeCollapseAct:
                if action == self.nodeExpandAct:
                    self.R.do_expanding_one_r(node)
                elif action == self.nodeCollapseAct:
                    self.R.do_collapsing_parent(node)
                if self.R.animationOn == 0:
                    self.R.layout()
                    self.update()
            elif action == self.nodeHighlightAct:
                self.R.switch_node_highlight(node)
                self.R.update()
        else:
            cmenu = self.W.cmenu
            action = cmenu.exec_(self.mapToGlobal(e.pos()))

    def switch_layout_to(self, lt):
        self.R.removeViewport(sip.unwrapinstance(self))
        self.R.addViewport(sip.unwrapinstance(self), lt)
        self.currentLayout = lt
        self.R.layout(lt)
        self.resetBaseXY()
        self.update()
               
        
class DAGViz(QMainWindow):
    def __init__(self):
        super(DAGViz, self).__init__()
        # DAGs
        for arg in sys.argv[1:]:
            R = dagrenderer.DAGRenderer()
            R.setDAG(arg)
            renderers.append(R)
        # UI
        self.initUI()
        # central widget (viewport division)
        self.V = None
        self.viewports = []
        self.currentDivision = -1
        self.centralWidget = None
        if len(renderers) == 1:
            self.dagDivisionsActGroup.actions()[4].setChecked(True)
        elif len(renderers) == 2:
            self.dagDivisionsActGroup.actions()[5].setChecked(True)
        elif len(renderers) == 3:
            self.dagDivisionsActGroup.actions()[8].setChecked(True)
        else:
            self.dagDivisionsActGroup.actions()[0].setChecked(True)
        self.reset_dags_and_viewports()
        # show
        self.show()
        # initial DAG expansion
        for R in renderers:
            R.do_expanding_one()
            R.do_expanding_one()
        
    def initUI(self):
        # main window
        self.setGeometry(0, 0, 1100, 800)
        self.center()
        self.setWindowTitle('DAGViz')
        self.setWindowIcon(QIcon(sysroot + '/gui/dagviz_icon.svg'))

        # status bar
        self.statusBar().showMessage('Tips: scroll to zoom, Ctrl and scroll (or double click and drag) to move')

        # menu bar
        menubar = self.menuBar()
        #menubar.setNativeMenuBar(False)
        fileMenu = menubar.addMenu('&File')
        editMenu = menubar.addMenu('&Edit')
        viewMenu = menubar.addMenu('&View')

        # file
        exitAct = QAction(QIcon(sysroot + '/gui/exit.svg'), '&Exit', self)
        exitAct.setShortcut('Ctrl+Q')
        exitAct.setStatusTip('Exit application')
        exitAct.triggered.connect(qApp.quit)
        fileMenu.addAction(exitAct)

        # edit
        expandAct = QAction(QIcon(sysroot + '/gui/plus_button_icon.svg'), 'E&xpand DAG one depth (X)', self)
        expandAct.setShortcut('X')
        expandAct.setStatusTip('Expand DAG one depth (X)')
        expandAct.triggered.connect(self.onExpandAct)
        editMenu.addAction(expandAct)
        collapseAct = QAction(QIcon(sysroot + '/gui/minus_button_icon.svg'), '&Collapse DAG one depth (C)', self)
        collapseAct.setShortcut('C')
        collapseAct.setStatusTip('Collapse DAG one depth (C)')
        collapseAct.triggered.connect(self.onCollapseAct)
        editMenu.addAction(collapseAct)

        # view
        viewportDivisions = viewMenu.addMenu('Viewport &divisions')
        self.dagDivisionsActGroup = QActionGroup(viewportDivisions)
        self.dagDivisionsActGroup.setExclusive(True)
        oneDagDivisions = viewportDivisions.addMenu('Viewport divisions for &one DAG')
        oneDivAct0 = oneDagDivisions.addAction('Basic DAG')
        oneDivAct0.setCheckable(True)
        oneDivAct0.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(oneDivAct0)
        oneDivAct1 = oneDagDivisions.addAction('Basic DAG | Timing DAG')
        oneDivAct1.setCheckable(True)
        oneDivAct1.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(oneDivAct1)
        oneDivAct2 = oneDagDivisions.addAction('Basic DAG | Timelines')
        oneDivAct2.setCheckable(True)
        oneDivAct2.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(oneDivAct2)
        oneDivAct3 = oneDagDivisions.addAction('Timing DAG | Timelines')
        oneDivAct3.setCheckable(True)
        oneDivAct3.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(oneDivAct3)
        oneDivAct4 = oneDagDivisions.addAction('Basic DAG | Timing DAG / Timelines')
        oneDivAct4.setCheckable(True)
        oneDivAct4.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(oneDivAct4)
        oneDagDivisions.addSeparator()
        self.chooseOneDagMenu = oneDagDivisions.addMenu('Choose one DAG')
        self.chooseOneDagActGroup = QActionGroup(self.chooseOneDagMenu)
        self.chooseOneDagActGroup.setExclusive(True)
        for R in renderers:
            chooseOneDagAct = self.chooseOneDagMenu.addAction('DAG %i: %s' % (renderers.index(R), R.shortName))
            chooseOneDagAct.setCheckable(True)
            chooseOneDagAct.setStatusTip(R.fileName)
            chooseOneDagAct.triggered.connect(self.reset_dags_and_viewports)
            self.chooseOneDagActGroup.addAction(chooseOneDagAct)
        twoDagDivisions = viewportDivisions.addMenu('Viewport divisions for &two DAG')
        twoDivAct1 = twoDagDivisions.addAction('Basic DAG | Basic DAG')
        twoDivAct1.setCheckable(True)
        twoDivAct1.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(twoDivAct1)
        twoDivAct2 = twoDagDivisions.addAction('(Timing DAG | Timelines) / (Timing DAG | Timelines)')
        twoDivAct2.setCheckable(True)
        twoDivAct2.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(twoDivAct2)
        twoDivAct3 = twoDagDivisions.addAction('(Basic|Timing/Timelines) | (Basic|Timing/Timelines)')
        twoDivAct3.setCheckable(True)
        twoDivAct3.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(twoDivAct3)
        twoDagDivisions.addSeparator()
        self.chooseTwoDagMenu = twoDagDivisions.addMenu('Choose two DAGs')
        self.chooseTwoDagActGroup = QActionGroup(self.chooseTwoDagMenu)
        self.chooseTwoDagActGroup.setExclusive(False)
        for R in renderers:
            chooseTwoDagAct = self.chooseTwoDagMenu.addAction('DAG %i: %s' % (renderers.index(R), R.shortName))
            chooseTwoDagAct.setCheckable(True)
            chooseTwoDagAct.setStatusTip(R.fileName)
            chooseTwoDagAct.triggered.connect(self.reset_dags_and_viewports)
            self.chooseTwoDagActGroup.addAction(chooseTwoDagAct)
        threeDagDivisions = viewportDivisions.addMenu('Viewport divisions for th&ree DAG')
        threeDivAct1 = threeDagDivisions.addAction('Basic DAG | Basic DAG | Basic DAG')
        threeDivAct1.setCheckable(True)
        threeDivAct1.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(threeDivAct1)
        threeDivAct2 = threeDagDivisions.addAction('Timing DAG | Timing DAG | Timing DAG')
        threeDivAct2.setCheckable(True)
        threeDivAct2.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(threeDivAct2)
        threeDivAct3 = threeDagDivisions.addAction('Timelines | Timelines | Timelines')
        threeDivAct3.setCheckable(True)
        threeDivAct3.triggered.connect(self.reset_dags_and_viewports)
        self.dagDivisionsActGroup.addAction(threeDivAct3)
        threeDagDivisions.addSeparator()
        self.chooseThreeDagMenu = threeDagDivisions.addMenu('Choose three DAGs')
        self.chooseThreeDagActGroup = QActionGroup(self.chooseThreeDagMenu)
        self.chooseThreeDagActGroup.setExclusive(False)
        for R in renderers:
            chooseThreeDagAct = self.chooseThreeDagMenu.addAction('DAG %i: %s' % (renderers.index(R), R.shortName))
            chooseThreeDagAct.setCheckable(True)
            chooseThreeDagAct.setStatusTip(R.fileName)
            chooseThreeDagAct.triggered.connect(self.reset_dags_and_viewports)
            self.chooseThreeDagActGroup.addAction(chooseThreeDagAct)
        viewMenu.addSeparator()
        viewTypeMenu = viewMenu.addMenu('&View types')
        dagViewAct = viewTypeMenu.addAction('DAG')
        dagViewAct.setShortcut(Qt.Key_1)
        dagViewAct.setIcon(QIcon(sysroot + '/gui/dag_icon.svg'))
        dagViewAct.setToolTip('Switch to basic DAG (1)')
        dagViewAct.setStatusTip('Switch to basic DAG view (1)')
        dagViewAct.triggered.connect(self.onDagViewAct)
        dagtimingViewAct = viewTypeMenu.addAction('DAG with timing')
        dagtimingViewAct.setIcon(QIcon(sysroot + '/gui/dag_boxes_icon.svg'))
        dagtimingViewAct.setToolTip('Switch to DAG with timing (2)')
        dagtimingViewAct.setStatusTip('Switch to DAG with timing on y-axis (2)')
        dagtimingViewAct.triggered.connect(self.onDagLinearViewAct)
        dagtimingViewActMenu = QMenu(self)
        linearAct = dagtimingViewActMenu.addAction(u"Linear scale (time\u00F7a)")
        linearAct.setShortcut(Qt.Key_2)
        linearAct.setToolTip(u"scale times (y-axis) down with linear function: time\u00F7a (2)")
        linearAct.setStatusTip(u"scale times (y-axis) down with linear function: time\u00F7a (2)")
        linearAct.triggered.connect(self.onDagLinearViewAct)
        powerAct = dagtimingViewActMenu.addAction(u"Power scale (time\u1d43)")
        powerAct.setShortcut(Qt.Key_3)
        powerAct.setToolTip(u"scale times (y-axis) down with power function: time\u1d43 (3)")
        powerAct.setStatusTip(u"scale times (y-axis) down with powerfunction: time\u1d43 (3)")
        powerAct.triggered.connect(self.onDagPowerViewAct)
        logAct = dagtimingViewActMenu.addAction("Logarithmic scale (log\u2090time)")
        logAct.setShortcut(Qt.Key_4)
        logAct.setToolTip(u"scale times (y-axis) down with logarithmic function: log\u2090time (4)")
        logAct.setStatusTip(u"scale times (y-axis) down with logarithmic function: log\u2090time (4)")
        logAct.triggered.connect(self.onDagLogViewAct)
        dagtimingViewAct.setMenu(dagtimingViewActMenu)
        dagtimingViewActMenu.addSeparator()
        adjustAct = dagtimingViewActMenu.addAction(u"Adjust scaling factor (a) with SHIFT + mouse scrolling")
        adjustAct.setCheckable(True)
        adjustAct.setChecked(True)
        self.adjustScalingFactorEnabled = True
        paraprofViewAct = viewTypeMenu.addAction('Timelines with parallelism profile')
        paraprofViewAct.setShortcut(Qt.Key_5)
        paraprofViewAct.setIcon(QIcon(sysroot + '/gui/paraprof_icon.svg'))
        paraprofViewAct.setToolTip('Switch to timelines with parallelism profile (5)')
        paraprofViewAct.setStatusTip('Switch to timelines view with parallelism profile on top (5)')
        paraprofViewAct.triggered.connect(self.onDagParaprofViewAct)
        
        # showhideMenu = viewMenu.addMenu('Sh&ow/Hide')
        # replayAct = QAction('&Replay', self, checkable=True)
        # replayAct.setShortcut('Shift+Ctrl+R')
        # replayAct.setChecked(False)
        # #replayAct.triggered.connect(qApp.quit)
        # nodeinfoAct = QAction('&Node information', self, checkable=True)
        # nodeinfoAct.setShortcut('Shift+Ctrl+N')
        # nodeinfoAct.setChecked(False)
        # #nodeinfoAct.triggered.connect(qApp.quit)
        # showhideMenu.addAction(replayAct)
        # showhideMenu.addAction(nodeinfoAct)

        zoomMenu = viewMenu.addMenu('&Zoom')
        zoomInAct = zoomMenu.addAction('Zoom In')
        zoomInAct.setShortcut('+')
        zoomInAct.triggered.connect(self.onZoomInAct)
        zoomOutAct = zoomMenu.addAction('Zoom Out')
        zoomOutAct.setShortcut('-')
        zoomOutAct.triggered.connect(self.onZoomOutAct)
        zoomMenu.addSeparator()
        zoomFullAct = zoomMenu.addAction('Fit &Full (F)')
        zoomFullAct.setShortcut('F')
        zoomFullAct.setIcon(QIcon(sysroot + '/gui/fit_button_icon.svg'))
        zoomFullAct.setStatusTip('Fit Full (F)')
        zoomFullAct.triggered.connect(self.onZoomFullAct)
        zoomHorAct = self.zoomHorAct = zoomMenu.addAction('Fit &Horizontally')
        zoomHorAct.setShortcut('H')
        zoomHorAct.triggered.connect(self.onZoomHorAct)
        zoomVerAct = zoomMenu.addAction('Fit &Vertically')
        zoomVerAct.setShortcut('V')
        zoomVerAct.triggered.connect(self.onZoomVerAct)

        viewMenu.addSeparator()
        switchViewportAct = viewMenu.addAction("&Switch focused viewport")
        switchViewportAct.setShortcut('Ctrl+Tab')
        switchViewportAct.triggered.connect(self.switchFocusedViewport)

        # toolbar
        self.toolbar = self.addToolBar('Toolbar')
        viewportDivisionsBut = QToolButton()
        viewportDivisionsBut.setIcon(QIcon(sysroot + '/gui/viewport_division_icon.svg'))
        viewportDivisionsBut.setMenu(viewportDivisions)
        viewportDivisionsBut.setPopupMode(QToolButton.InstantPopup)
        self.toolbar.addWidget(viewportDivisionsBut)
        self.toolbar.addSeparator()
        self.toolbar.addAction(dagViewAct)
        self.toolbar.addAction(dagtimingViewAct)
        self.toolbar.addAction(paraprofViewAct)
        self.toolbar.addSeparator()
        self.toolbar.addAction(zoomFullAct)
        self.toolbar.addAction(expandAct)
        self.toolbar.addAction(collapseAct)
        self.toolbar.addSeparator()
        searchAct = self.toolbar.addAction('Search node (S)')
        searchAct.setShortcut('S')
        searchAct.setIcon(QIcon(sysroot + '/gui/search_icon.svg'))
        searchAct.triggered.connect(self.onSearchAct)

        # context menu
        self.cmenu = QMenu(self)
        self.cmenu.addAction(expandAct)
        self.cmenu.addAction(collapseAct)
        self.cmenu.addSeparator()
        zoomMenu = self.cmenu.addMenu('&Zoom')
        zoomMenu.addAction(zoomFullAct)
        zoomMenu.addAction(zoomHorAct)
        zoomMenu.addAction(zoomVerAct)

        # hidden actions
        moveUpAct = QAction(self)
        moveUpAct.setShortcut(Qt.Key_Up)
        moveUpAct.triggered.connect(self.onMoveUpAct)
        self.addAction(moveUpAct)
        moveDownAct = QAction(self)
        moveDownAct.setShortcut(Qt.Key_Down)
        moveDownAct.triggered.connect(self.onMoveDownAct)
        self.addAction(moveDownAct)
        moveLeftAct = QAction(self)
        moveLeftAct.setShortcut(Qt.Key_Left)
        moveLeftAct.triggered.connect(self.onMoveLeftAct)
        self.addAction(moveLeftAct)
        moveRightAct = QAction(self)
        moveRightAct.setShortcut(Qt.Key_Right)
        moveRightAct.triggered.connect(self.onMoveRightAct)
        self.addAction(moveRightAct)

    def onSearchAct(self):
        (node_id,ok) = QInputDialog.getInt(self, "Search node", "Node ID:", QLineEdit.Normal)
        if ok:
            node = self.V.R.find_node_with_node_index(node_id)
            if node is not None:
                self.V.R.switch_node_highlight(node)
                self.V.R.update()

    def viewport_division_for_one_dag_type_0(self, R):
        V = Viewport(self, R, R.LAYOUT_TYPE_1)
        self.viewports.append(V)
        return V.containerWithScrollBars
    def viewport_division_for_one_dag_type_1(self, R):
        V1 = Viewport(self, R, R.LAYOUT_TYPE_1)
        self.viewports.append(V1)
        V2 = Viewport(self, R, R.LAYOUT_TYPE_2)
        self.viewports.append(V2)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(V1.containerWithScrollBars)
        splitter.addWidget(V2.containerWithScrollBars)
        return splitter
    def viewport_division_for_one_dag_type_2(self, R):
        V1 = Viewport(self, R, R.LAYOUT_TYPE_1)
        self.viewports.append(V1)
        V2 = Viewport(self, R, R.LAYOUT_TYPE_5)
        self.viewports.append(V2)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(V1.containerWithScrollBars)
        splitter.addWidget(V2.containerWithScrollBars)
        return splitter
    def viewport_division_for_one_dag_type_3(self, R):
        V1 = Viewport(self, R, R.LAYOUT_TYPE_2)
        self.viewports.append(V1)
        V2 = Viewport(self, R, R.LAYOUT_TYPE_5)
        self.viewports.append(V2)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(V1.containerWithScrollBars)
        splitter.addWidget(V2.containerWithScrollBars)
        return splitter
    def viewport_division_for_one_dag_type_4(self, R):
        V1 = Viewport(self, R, R.LAYOUT_TYPE_1)
        self.viewports.append(V1)
        V2 = Viewport(self, R, R.LAYOUT_TYPE_2)
        self.viewports.append(V2)
        V3 = Viewport(self, R, R.LAYOUT_TYPE_5)
        self.viewports.append(V3)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(V1.containerWithScrollBars)
        splitter.addWidget(V2.containerWithScrollBars)
        splitter2 = QSplitter(Qt.Vertical)
        splitter2.setContentsMargins(0, 0, 0, 0)
        splitter2.addWidget(splitter)
        splitter2.addWidget(V3.containerWithScrollBars)
        return splitter2

    def viewport_division_for_two_dag_type_0(self, R1, R2):
        V1 = Viewport(self, R1, R1.LAYOUT_TYPE_1)
        self.viewports.append(V1)
        V2 = Viewport(self, R2, R2.LAYOUT_TYPE_1)
        self.viewports.append(V2)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(V1.containerWithScrollBars)
        splitter.addWidget(V2.containerWithScrollBars)
        return splitter
    def viewport_division_for_two_dag_type_1(self, R1, R2):
        V1 = Viewport(self, R1, R1.LAYOUT_TYPE_2)
        self.viewports.append(V1)
        V2 = Viewport(self, R1, R1.LAYOUT_TYPE_5)
        self.viewports.append(V2)
        s1 = QSplitter(Qt.Vertical)
        s1.setContentsMargins(0, 0, 0, 0)
        s1.addWidget(V1.containerWithScrollBars)
        s1.addWidget(V2.containerWithScrollBars)
        V3 = Viewport(self, R2, R2.LAYOUT_TYPE_2)
        self.viewports.append(V3)
        V4 = Viewport(self, R2, R2.LAYOUT_TYPE_5)
        self.viewports.append(V4)
        s2 = QSplitter(Qt.Vertical)
        s2.setContentsMargins(0, 0, 0, 0)
        s2.addWidget(V3.containerWithScrollBars)
        s2.addWidget(V4.containerWithScrollBars)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(s1)
        splitter.addWidget(s2)
        return splitter
    def viewport_division_for_two_dag_type_2(self, R1, R2):
        s1 = self.viewport_division_for_one_dag_type_4(R1)
        s2 = self.viewport_division_for_one_dag_type_4(R2)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(s1)
        splitter.addWidget(s2)
        return splitter
        
    def viewport_division_for_three_dag_type_0(self, R1, R2, R3):
        V1 = Viewport(self, R1, R1.LAYOUT_TYPE_1)
        self.viewports.append(V1)
        V2 = Viewport(self, R2, R2.LAYOUT_TYPE_1)
        self.viewports.append(V2)
        V3 = Viewport(self, R3, R3.LAYOUT_TYPE_1)
        self.viewports.append(V3)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(V1.containerWithScrollBars)
        splitter.addWidget(V2.containerWithScrollBars)
        splitter.addWidget(V3.containerWithScrollBars)
        return splitter
    def viewport_division_for_three_dag_type_1(self, R1, R2, R3):
        V1 = Viewport(self, R1, R1.LAYOUT_TYPE_2)
        self.viewports.append(V1)
        V2 = Viewport(self, R2, R2.LAYOUT_TYPE_2)
        self.viewports.append(V2)
        V3 = Viewport(self, R3, R3.LAYOUT_TYPE_2)
        self.viewports.append(V3)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(V1.containerWithScrollBars)
        splitter.addWidget(V2.containerWithScrollBars)
        splitter.addWidget(V3.containerWithScrollBars)
        return splitter
    def viewport_division_for_three_dag_type_2(self, R1, R2, R3):
        V1 = Viewport(self, R1, R1.LAYOUT_TYPE_5)
        self.viewports.append(V1)
        V2 = Viewport(self, R2, R2.LAYOUT_TYPE_5)
        self.viewports.append(V2)
        V3 = Viewport(self, R3, R3.LAYOUT_TYPE_5)
        self.viewports.append(V3)
        splitter = QSplitter(Qt.Horizontal)
        splitter.setContentsMargins(0, 0, 0, 0)
        splitter.addWidget(V1.containerWithScrollBars)
        splitter.addWidget(V2.containerWithScrollBars)
        splitter.addWidget(V3.containerWithScrollBars)
        return splitter

    def reset_dags_and_viewports_one_dag(self, division, R):
        if division == 0:
            return self.viewport_division_for_one_dag_type_0(R)
        elif division == 1:
            return self.viewport_division_for_one_dag_type_1(R)
        elif division == 2:
            return self.viewport_division_for_one_dag_type_2(R)
        elif division == 3:
            return self.viewport_division_for_one_dag_type_3(R)
        elif division == 4:
            return self.viewport_division_for_one_dag_type_4(R)
        else:
            print('[Error] division=%i is not for one DAG.' % division)
            return None
    def reset_dags_and_viewports_two_dags(self, division, R1, R2):
        if division == 5:
            return self.viewport_division_for_two_dag_type_0(R1, R2)
        elif division == 6:
            return self.viewport_division_for_two_dag_type_1(R1, R2)
        elif division == 7:
            return self.viewport_division_for_two_dag_type_2(R1, R2)
        else:
            print('[Error] division=%i is not for two DAGs.' % division)
            return None
    def reset_dags_and_viewports_three_dags(self, division, R1, R2, R3):
        if division == 8:
            return self.viewport_division_for_three_dag_type_0(R1, R2, R3)
        elif division == 9:
            return self.viewport_division_for_three_dag_type_1(R1, R2, R3)
        elif division == 10:
            return self.viewport_division_for_three_dag_type_2(R1, R2, R3)
        else:
            print('[Error] division=%i is not for three DAGs.' % division)
        
    def reset_dags_and_viewports_(self, division, Rs):
        for V in self.viewports:
            V.R.removeViewport(sip.unwrapinstance(V))
            del V
        self.viewports = []
        
        if division in [0,1,2,3,4]:
            (R) = Rs
            self.centralWidget = self.reset_dags_and_viewports_one_dag(division, R)
        elif division in [5,6,7]:
            (R1,R2) = Rs
            self.centralWidget = self.reset_dags_and_viewports_two_dags(division, R1, R2)
        elif division in [8,9,10]:
            (R1,R2,R3) = Rs
            self.centralWidget = self.reset_dags_and_viewports_three_dags(division, R1, R2, R3)
        else:
            print('[Error] unknown division=%i.' % division)
            
        if len(self.viewports) > 0 and (self.V == None or self.V not in self.viewports):
            self.setFocusedViewport(self.viewports[0])
        self.setCentralWidget(self.centralWidget)
        
    def reset_dags_and_viewports(self):
        checkedAction = self.dagDivisionsActGroup.checkedAction()
        if checkedAction is None:
            return
        # Get selected division and DAG(s)
        selectedDivision = self.dagDivisionsActGroup.actions().index(checkedAction)
        if selectedDivision != self.currentDivision:
            if selectedDivision in [0,1,2,3,4]:
                # one-dag divisions
                if len(renderers) < 1:
                    print('[Warning] there is no DAG.')
                    return
                if self.chooseOneDagActGroup.checkedAction() is None:
                    self.chooseOneDagActGroup.actions()[0].setChecked(True)
                selectedR = (renderers[self.chooseOneDagActGroup.actions().index(self.chooseOneDagActGroup.checkedAction())])
                self.reset_dags_and_viewports_(selectedDivision, selectedR)
            elif selectedDivision in [5,6,7]:
                # two-dag divisions
                if len(renderers) < 2:
                    self.dagDivisionsActGroup.actions()[self.currentDivision].setChecked(True)
                    print('[Warning] there are not enough two DAGs.')
                    return
                selectedR1 = None
                selectedR2 = None
                actions = self.chooseTwoDagActGroup.actions()
                for act in actions:
                    if act.isChecked():
                        if selectedR1 is None:
                            selectedR1 = renderers[actions.index(act)]
                        elif selectedR2 is None:
                            selectedR2 = renderers[actions.index(act)]
                if selectedR1 is None or selectedR2 is None:
                    for act in actions:
                        if not act.isChecked():
                            if selectedR1 is None:
                                selectedR1 = renderers[actions.index(act)]
                                act.setChecked(True)
                            elif selectedR2 is None:
                                selectedR2 = renderers[actions.index(act)]
                                act.setChecked(True)
                selectedR = (selectedR1,selectedR2)
                self.reset_dags_and_viewports_(selectedDivision, selectedR)
            elif selectedDivision in [8,9,10]:
                # three-dag divisions
                if len(renderers) < 3:
                    self.dagDivisionsActGroup.actions()[self.currentDivision].setChecked(True)
                    print('[Warning] there are not enough three DAGs.')
                    return
                selectedR1 = None
                selectedR2 = None
                selectedR3 = None
                actions = self.chooseThreeDagActGroup.actions()
                for act in actions:
                    if act.isChecked():
                        if selectedR1 is None:
                            selectedR1 = renderers[actions.index(act)]
                        elif selectedR2 is None:
                            selectedR2 = renderers[actions.index(act)]
                        elif selectedR3 is None:
                            selectedR3 = renderers[actions.index(act)]
                if selectedR1 is None or selectedR2 is None or selectedR3 is None:
                    for act in actions:
                        if not act.isChecked():
                            if selectedR1 is None:
                                selectedR1 = renderers[actions.index(act)]
                                act.setChecked(True)
                            elif selectedR2 is None:
                                selectedR2 = renderers[actions.index(act)]
                                act.setChecked(True)                    
                            elif selectedR3 is None:
                                selectedR3 = renderers[actions.index(act)]
                                act.setChecked(True)
                selectedR = (selectedR1,selectedR2,selectedR3)
                self.reset_dags_and_viewports_(selectedDivision, selectedR)
            else:
                print('[Error] unknown division selected.')
                return
            self.currentDivision = selectedDivision
        
    def setFocusedViewport(self, V):
        if V in self.viewports:
            if self.V is not None:
                self.V.marker.disable()
            if V is not None:
                self.V = V
                self.V.marker.enable()

    def switchFocusedViewport(self):
        V = self.V
        if V is None:
            V = self.viewports[0]
        else:
            i = self.viewports.index(V)
            i = (i + 1) % len(self.viewports)
            V = self.viewports[i]
        self.setFocusedViewport(V)
        
    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Up:
            self.V.move_up()
        if e.key() == Qt.Key_Down:
            self.V.move_down()
        if e.key() == Qt.Key_Left:
            self.V.move_left()
        elif e.key() == Qt.Key_Right:
            self.V.move_right()

    def onExpandAct(self, e):
        self.V.do_expanding_one()
    def onCollapseAct(self, e):
        self.V.do_collapsing_one()
        
    def onDagViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_1)
    def onDagLinearViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_2)
    def onDagPowerViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_3)
    def onDagLogViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_4)
    def onDagParaprofViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_5)
        
    def onZoomInAct(self):
        self.V.do_zoom_in()
    def onZoomOutAct(self):
        self.V.do_zoom_out()
    def onZoomFullAct(self):
        self.V.do_zoom_fit_full()
    def onZoomHorAct(self):
        self.V.do_zoom_fit_hor()
    def onZoomVerAct(self):
        self.V.do_zoom_fit_ver()

    def onMoveUpAct(self):
        self.V.move_up()
    def onMoveDownAct(self):
        self.V.move_down()
    def onMoveLeftAct(self):
        self.V.move_left()
    def onMoveRightAct(self):
        self.V.move_right()

    # def closeEvent(self, event):
    #     print("closeEvent handler.")
    #     reply = QMessageBox.question(self, 'Message', "Are you sure to quit?",
    #                                  QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
    #     if reply == QMessageBox.Yes:
    #         event.accept()
    #     else:
    #         event.ignore()

    def center(self):
        windowrec = self.frameGeometry()
        centerpt = QDesktopWidget().availableGeometry().center()
        windowrec.moveCenter(centerpt)
        self.move(windowrec.topLeft())

        
if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = DAGViz()
    sys.exit(app.exec_())
