#!/usr/bin/python3

import sys, os, random

#from PyQt5.QtGui import QIcon, QFont
#from PyQt5.QtWidgets import QApplication, QWidget, QToolTip, QPushButton
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

import sip
sysroot = os.path.dirname(os.path.realpath(sys.argv[0]))
sys.path.append(sysroot + "/sip")
import dagrenderer

GO = {
    "zoom_rate_per_time" : 0.08,   # rate per scrolling time
    "zoom_rate_per_pixel" : 0.004, # rate per scrolling pixel: 0.08 / 20
    "zoom_default_weight" : 20,    # rate in pixel unit on one default zoom
    "margin_top"    : 20,
    "margin_bottom" : 20,
    "margin_left"   : 20,
    "margin_right"  : 20,
    "moving_distance" : 25.0,      # pixels, moving distance when pressing arrow keys
    "moving_distance_rate" : 20.0, # times, multiplied rate with modifier keys (Ctrl > Alt)
    "auto_zoom_fit" : 1, # automatically zoom to fit at the beginning: 0->none, 1->full, 2->hor, 3->ver
    "scaling_radix_scrolling_rate": 0.004, # rate for adjusting scaling radix at each scrolling
}
renderers = []

class DAGViewport(QWidget):
    def __init__(self, W):
        super(DAGViewport, self).__init__()
        self.W = W
        # background color
        pal = self.palette()
        pal.setColor(QPalette.Window, Qt.white)
        self.setPalette(pal)
        self.setAutoFillBackground(True)
        self.base_x = GO["margin_left"]
        self.base_y = GO["margin_top"]
        self.x = 0.0
        self.y = 0.0
        self.pan_on = False
        self.x_mouse_pressed = 0
        self.y_mouse_pressed = 0
        self.mouseCenteredExpansion = False
        self.x_mouse = 0
        self.y_mouse = 0
        self.setMouseTracking(True)
        self.R = None
        # DAGs
        #for arg in sys.argv[1:]:
        if (len(sys.argv) > 1):
            arg = sys.argv[1]
            self.R = dagrenderer.DAGRenderer()
            self.R.setDAG(arg)
            self.currentLayout = None
            self.switch_layout_to_dag()
            renderers.append(self.R)
        self.zoom_ratio_x = 1.0
        self.zoom_ratio_y = 1.0
        self.width
        # node context menu
        self.node_cmenu = QMenu(self)
        self.nodeExpandAct = self.node_cmenu.addAction("E&xpand node")
        self.nodeCollapseAct = self.node_cmenu.addAction("&Collapse parent node one depth")
        self.node_cmenu.addSeparator()
        # default action when clicked
        clickedActMenu = self.node_cmenu.addMenu("&Default action when clicked")
        self.nodeClickedActGroup = QActionGroup(clickedActMenu)
        self.nodeClickedActGroup.setExclusive(True)
        self.nodeExpandActDef = clickedActMenu.addAction("E&xpand node")
        self.nodeExpandActDef.setCheckable(True)
        self.nodeClickedActGroup.addAction(self.nodeExpandActDef)
        self.nodeCollapseActDef = clickedActMenu.addAction("&Collapse parent node one depth")
        self.nodeCollapseActDef.setCheckable(True)
        self.nodeClickedActGroup.addAction(self.nodeCollapseActDef)
        self.clickedNoneActDef = clickedActMenu.addAction("&None")
        self.clickedNoneActDef.setCheckable(True)
        self.nodeClickedActGroup.addAction(self.clickedNoneActDef)
        self.nodeExpandActDef.setChecked(True)
        # default action when hovered
        hoveredActMenu = self.node_cmenu.addMenu("&Default action when hovered")
        self.nodeHoveredActGroup = QActionGroup(hoveredActMenu)
        self.nodeHoveredActGroup.setExclusive(True)
        self.nodeInfoTooltipActDef = hoveredActMenu.addAction("Show node &information tooltip")
        self.nodeInfoTooltipActDef.setCheckable(True)
        self.nodeHoveredActGroup.addAction(self.nodeInfoTooltipActDef)
        self.hoveredNoneActDef = hoveredActMenu.addAction("&None")
        self.hoveredNoneActDef.setCheckable(True)
        self.nodeHoveredActGroup.addAction(self.hoveredNoneActDef)
        self.nodeInfoTooltipActDef.setChecked(True)
        # Initial DAG expansion
        self.do_expanding_one()
        self.do_expanding_one()

    def resizeEvent(self, e):
        old_w = e.oldSize().width()
        margin = GO["margin_left"] + GO["margin_right"]
        if old_w >= 0:
            self.base_x -= (old_w - margin) / 2.0
        self.base_x += (self.width() - margin) / 2.0

    def update(self):
        super(DAGViewport, self).update()

    def convert_x_to_dag_space(self, x):
        return (x - self.x - self.base_x) / self.zoom_ratio_x
    def convert_y_to_dag_space(self, y):
        return (y - self.y - self.base_y) / self.zoom_ratio_y
    def convert_x_from_dag_space(self, x):
        return x * self.zoom_ratio_x + self.x + self.base_x
    def convert_y_from_dag_space(self, y):
        return y * self.zoom_ratio_y + self.y + self.base_y
    def convert_dx_from_dag_space(self, dx):
        return dx * self.zoom_ratio_x
    def convert_dy_from_dag_space(self, dy):
        return dy * self.zoom_ratio_y
        
    def paintEvent(self, e):
        # adjusted deltas from Renderer
        Rdx = self.convert_dx_from_dag_space(self.R.getDx())
        Rdy = self.convert_dy_from_dag_space(self.R.getDy())
        self.x += Rdx
        self.y += Rdy
        # auto zoom fit
        if GO["auto_zoom_fit"] == 1:
            self.do_zoom_fit_full_auto()
        elif GO["auto_zoom_fit"] == 2:
            self.do_zoom_fit_hor_auto()
        elif GO["auto_zoom_fit"] == 3:
            self.do_zoom_fit_ver_auto()
        qp = QPainter(self)
        qp.translate(self.base_x, self.base_y)
        qp.translate(self.x, self.y)
        qp.scale(self.zoom_ratio_x, self.zoom_ratio_y)
        if self.R is not None:
            if (self.mouseCenteredExpansion):
                self.R.draw(sip.unwrapinstance(qp),
                            self.convert_x_to_dag_space(self.x_mouse),
                            self.convert_y_to_dag_space(self.y_mouse))
            else:
                self.R.draw(sip.unwrapinstance(qp))

    def do_moving(self, dx, dy):
        self.x = self.x + dx
        self.y = self.y + dy
        GO["auto_zoom_fit"] = False
        self.update()

    def do_zooming(self, x, y, weight):
        if weight != 0:
            new_zx = self.zoom_ratio_x
            new_zy = self.zoom_ratio_y
            factor = 1 + GO["zoom_rate_per_pixel"] * abs(weight)
            if weight > 0:
                new_zx *= factor
                new_zy *= factor
            else:
                new_zx /= factor
                new_zy /= factor
            x_dag = self.convert_x_to_dag_space(x)
            y_dag = self.convert_y_to_dag_space(y)
            self.zoom_ratio_x = new_zx
            self.zoom_ratio_y = new_zy
            new_x = self.convert_x_from_dag_space(x_dag)
            new_y = self.convert_y_from_dag_space(y_dag)
            dx = new_x - x
            dy = new_y - y
            self.x -= dx
            self.y -= dy
            GO["auto_zoom_fit"] = False
            self.update()
        
    def change_dag_scaling_factor(self, weight):
        if weight != 0:
            if self.currentLayout == self.R.LAYOUT_TYPE_2 or self.currentLayout == self.R.LAYOUT_TYPE_3 or self.currentLayout == self.R.LAYOUT_TYPE_4:
                if self.currentLayout == self.R.LAYOUT_TYPE_2:
                    radix = self.R.getLinearRadix();
                elif self.currentLayout == self.R.LAYOUT_TYPE_3:
                    radix = self.R.getPowerRadix();
                elif self.currentLayout == self.R.LAYOUT_TYPE_4:
                    radix = self.R.getLogRadix();
                factor = 1 + GO["scaling_radix_scrolling_rate"] * abs(weight)
                if weight > 0:
                    radix *= factor
                else:
                    radix /= factor
                if self.currentLayout == self.R.LAYOUT_TYPE_2:
                    self.R.setLinearRadix(radix);
                elif self.currentLayout == self.R.LAYOUT_TYPE_3:
                    self.R.setPowerRadix(radix);
                elif self.currentLayout == self.R.LAYOUT_TYPE_4:
                    self.R.setLogRadix(radix);
                self.R.layout(self.currentLayout)
                self.update()
        
    def wheelEvent(self, e):
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            # moving
            self.do_moving(e.pixelDelta().x(), e.pixelDelta().y())
        elif mod == Qt.ShiftModifier:
            # scrolling scaling factor
            if self.W.adjustScalingFactorEnabled:
                weight = e.pixelDelta().y()
                self.change_dag_scaling_factor(weight)
        else:
            # zooming
            weight = e.pixelDelta().y()
            self.do_zooming(e.x(), e.y(), weight)
        self.update()

    def mousePressEvent(self, e):
        # only detect LeftButton (RightButton triggers context menus)
        if e.button() == Qt.LeftButton:
            # pan 
            self.x_mouse_pressed = e.x()
            self.y_mouse_pressed = e.y()
            self.pan_on = True
    def mouseReleaseEvent(self, e):
        # only detect LeftButton (RightButton triggers context menus)
        if e.button() == Qt.LeftButton:
            # pan
            self.pan_on = False
            # node clicked
            checkedAction = self.nodeClickedActGroup.checkedAction()
            if checkedAction != self.clickedNoneActDef:            
                x_dag = self.convert_x_to_dag_space(e.x())
                y_dag = self.convert_y_to_dag_space(e.y())
                node = self.R.find_node(x_dag, y_dag, self.currentLayout)
                if node is not None:
                    if checkedAction == self.nodeExpandActDef:
                        self.R.do_expanding_one_r(node)
                    elif checkedAction == self.nodeCollapseActDef:
                        self.R.do_collapsing_parent(node)
                    if self.R.animationOn == 0:
                        self.R.layout()
                        self.update()                    

    def enterEvent(self, e):
        #print("mouse enters")
        self.mouseCenteredExpansion = True
        None
        
    def leaveEvent(self, e):
        #print("mouse leaves")
        self.mouseCenteredExpansion = False
        None
        
    def mouseMoveEvent(self, e):
        self.x_mouse = e.x()
        self.y_mouse = e.y()
        if self.pan_on:
            self.x += e.x() - self.x_mouse_pressed
            self.y += e.y() - self.y_mouse_pressed
            self.x_mouse_pressed = e.x()
            self.y_mouse_pressed = e.y()
            GO["auto_zoom_fit"] = False
            self.update()
        else:
            # node hovered
            checkedAction = self.nodeHoveredActGroup.checkedAction()
            if checkedAction != self.hoveredNoneActDef:
                x_dag = self.convert_x_to_dag_space(e.x())
                y_dag = self.convert_y_to_dag_space(e.y())
                node = self.R.find_node(x_dag, y_dag, self.currentLayout)
                if node is not None:
                    if checkedAction == self.nodeInfoTooltipActDef:
                        info_dict = self.R.get_dag_node_info(node)
                        info_str = self.get_node_info_string(info_dict)
                        QToolTip.showText(e.globalPos(), info_str, self, QRect(), 30000)
                else:
                    if checkedAction == self.nodeInfoTooltipActDef:
                        QToolTip.showText(e.globalPos(), None, self)

    def get_node_info_string(self, d):
        s = ("Worker %i, CPU %i, node kind %i\n"
             "  t_1 (work): %i\n"
             "t_inf (span): %i\n"
             "earliest start time: %i\n"
             "    first ready time: %i\n"
             "       last start time: %i\n"
             "start: t=%i, worker %i, CPU %i (%s:%i)\n"
             "  end: t=%i, worker %i, CPU %i (%s:%i)\n"
             "counters=%s") % (
                 d["worker"], d["cpu"], d["kind"],
                 d["t_1"], d["t_inf"],
                 d["est"], d["first_ready_t"], d["last_start_t"],
                 d["start"][0], d["start"][1], d["start"][2], d["start"][3], d["start"][4],
                 d["end"][0], d["end"][1], d["end"][2], d["end"][3], d["end"][4],
                 d["counters"])
        return s

    def move_up(self):
        dx = 0.0
        dy = GO["moving_distance"]
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
    def move_down(self):
        dx = 0.0
        dy = - GO["moving_distance"]
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
    def move_left(self):
        dx = GO["moving_distance"]
        dy = 0.0
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
    def move_right(self):
        dx = - GO["moving_distance"]
        dy = 0.0
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
        
    def do_zoom_in(self):
        self.do_zooming(self.width() / 2, self.height() / 2, GO["zoom_default_weight"])
        
    def do_zoom_out(self):
        self.do_zooming(self.width() / 2, self.height() / 2, - GO["zoom_default_weight"])

    def get_zoom_fit_hor_attributes(self):
        x = 0.0
        y = 0.0
        z = 1.0
        if self.R == None:
            return x,y,z
        w1 = self.R.width(self.currentLayout)
        w2 = self.width() - GO["margin_left"] - GO["margin_right"]
        if w1 > w2:
            z = w2 / w1
        x -= z * (self.R.right_width(self.currentLayout) - self.R.left_width(self.currentLayout)) / 2
        return x,y,z
    def do_zoom_fit_hor_auto(self):
        x,y,z = self.get_zoom_fit_hor_attributes()
        self.x = x
        self.y = y
        self.zoom_ratio_x = z
        self.zoom_ratio_y = z
    def do_zoom_fit_hor(self):
        self.do_zoom_fit_hor_auto()
        GO["auto_zoom_fit"] = 2
        self.update()
            
    def get_zoom_fit_ver_attributes(self):
        x = 0.0
        y = 0.0
        z = 1.0
        if self.R == None:
            return x,y,z
        h1 = self.R.height(self.currentLayout)
        h2 = self.height() - GO["margin_top"] - GO["margin_bottom"]
        if h1 > h2:
            z = h2 / h1
        x -= z * (self.R.right_width(self.currentLayout) - self.R.left_width(self.currentLayout)) / 2
        return x,y,z
    def do_zoom_fit_ver_auto(self):
        x,y,z = self.get_zoom_fit_ver_attributes()
        self.x = x
        self.y = y
        self.zoom_ratio_x = z
        self.zoom_ratio_y = z
    def do_zoom_fit_ver(self):
        self.do_zoom_fit_ver_auto()
        GO["auto_zoom_fit"] = 3
        self.update()
        
    def do_zoom_fit_full_auto(self):
        x1,y1,z1 = self.get_zoom_fit_hor_attributes()
        x2,y2,z2 = self.get_zoom_fit_ver_attributes()
        if z1 < z2:
            self.x = x1
            self.y = y1
            self.zoom_ratio_x = z1
            self.zoom_ratio_y = z1
        else:
            self.x = x2
            self.y = y2
            self.zoom_ratio_x = z2
            self.zoom_ratio_y = z2
    def do_zoom_fit_full(self):
        self.do_zoom_fit_full_auto()
        GO["auto_zoom_fit"] = 1
        self.update()
        
    def do_expanding_one(self):
        if self.R is not None:
            self.R.do_expanding_one()
            if self.R.animationOn == 0:
                self.R.layout()
                self.update()
    
    def do_collapsing_one(self, e):
        if self.R is not None:
            self.R.do_collapsing_one()
            if self.R.animationOn == 0:
                self.R.layout()
                self.update()

    def contextMenuEvent(self, e):
        x_dag = self.convert_x_to_dag_space(e.x())
        y_dag = self.convert_y_to_dag_space(e.y())
        node = self.R.find_node(x_dag, y_dag, self.currentLayout)
        if node is not None:
            cmenu = self.node_cmenu
            action = cmenu.exec_(self.mapToGlobal(e.pos()))
            if action == self.nodeExpandAct:
                self.R.do_expanding_one_r(node)
            elif action == self.nodeCollapseAct:
                self.R.do_collapsing_parent(node)
            if self.R.animationOn == 0:
                self.R.layout()
                self.update()
        else:
            cmenu = self.W.cmenu
            action = cmenu.exec_(self.mapToGlobal(e.pos()))

    def switch_layout_to(self, lt):
        self.R.removeViewport(sip.unwrapinstance(self))
        self.R.addViewport(sip.unwrapinstance(self), lt)
        self.currentLayout = lt
        self.R.layout(lt)
        self.update()
    def switch_layout_to_dag(self):
        self.switch_layout_to(self.R.LAYOUT_TYPE_1)
    def switch_layout_to_dag_timing_linear(self):
        self.switch_layout_to(self.R.LAYOUT_TYPE_2)
    def switch_layout_to_dag_timing_power(self):
        self.switch_layout_to(self.R.LAYOUT_TYPE_3)
    def switch_layout_to_dag_timing_log(self):
        self.switch_layout_to(self.R.LAYOUT_TYPE_4)
    def switch_layout_to_paraprof(self):
        None
            
class DAGViz(QMainWindow):
    def __init__(self):
        super(DAGViz, self).__init__()
        self.VP = DAGViewport(self)
        self.initUI()
        
    def initUI(self):
        # main window
        self.setGeometry(0, 0, 1100, 800)
        self.center()
        self.setWindowTitle('DAGViz')
        self.setWindowIcon(QIcon(sysroot + '/gui/dagviz_icon.svg'))

        # status bar
        self.statusBar().showMessage('Ready')

        # menu bar
        menubar = self.menuBar()
        #menubar.setNativeMenuBar(False)
        fileMenu = menubar.addMenu('&File')
        editMenu = menubar.addMenu('&Edit')
        viewMenu = menubar.addMenu('&View')

        # file
        exitAct = QAction(QIcon(sysroot + '/gui/exit.svg'), '&Exit', self)
        exitAct.setShortcut('Ctrl+Q')
        exitAct.setStatusTip('Exit application')
        exitAct.triggered.connect(qApp.quit)
        fileMenu.addAction(exitAct)

        # edit
        expandAct = QAction(QIcon(sysroot + '/gui/plus_button_icon.svg'), 'E&xpand DAG one depth (X)', self)
        expandAct.setShortcut('X')
        expandAct.setStatusTip('Expand DAG one depth (X)')
        expandAct.triggered.connect(self.VP.do_expanding_one)
        editMenu.addAction(expandAct)
        collapseAct = QAction(QIcon(sysroot + '/gui/minus_button_icon.svg'), '&Collapse DAG one depth (C)', self)
        collapseAct.setShortcut('C')
        collapseAct.setStatusTip('Collapse DAG one depth (C)')
        collapseAct.triggered.connect(self.VP.do_collapsing_one)
        editMenu.addAction(collapseAct)

        # view
        viewTypeMenu = viewMenu.addMenu('&View types')
        dagViewAct = viewTypeMenu.addAction('DAG')
        dagViewAct.setShortcut(Qt.Key_1)
        dagViewAct.setIcon(QIcon(sysroot + '/gui/dag_icon.svg'))
        dagViewAct.setToolTip('Switch to basic DAG (1)')
        dagViewAct.setStatusTip('Switch to basic DAG view (1)')
        dagViewAct.triggered.connect(self.VP.switch_layout_to_dag)
        dagtimingViewAct = viewTypeMenu.addAction('DAG with timing')
        dagtimingViewAct.setIcon(QIcon(sysroot + '/gui/dag_boxes_icon.svg'))
        dagtimingViewAct.setToolTip('Switch to DAG with timing (2)')
        dagtimingViewAct.setStatusTip('Switch to DAG with timing on y-axis (2)')
        dagtimingViewAct.triggered.connect(self.VP.switch_layout_to_dag_timing_linear)
        dagtimingViewActMenu = QMenu(self)
        linearAct = dagtimingViewActMenu.addAction(u"Linear scale (time\u00F7a)")
        linearAct.setShortcut(Qt.Key_2)
        linearAct.setToolTip(u"scale times (y-axis) down with linear function: time\u00F7a (a=%i) (2)" % self.VP.R.getLinearRadix())
        linearAct.setStatusTip(u"scale times (y-axis) down with linear function: time\u00F7a (a=%i) (2)" % self.VP.R.getLinearRadix())
        linearAct.triggered.connect(self.VP.switch_layout_to_dag_timing_linear)
        powerAct = dagtimingViewActMenu.addAction(u"Power scale (time\u1d43)")
        powerAct.setShortcut(Qt.Key_3)
        powerAct.setToolTip(u"scale times (y-axis) down with power function: time\u1d43 (a=%f) (3)" % self.VP.R.getPowerRadix())
        powerAct.setStatusTip(u"scale times (y-axis) down with powerfunction: time\u1d43 (a=%f) (3)" % self.VP.R.getPowerRadix())
        powerAct.triggered.connect(self.VP.switch_layout_to_dag_timing_power)
        logAct = dagtimingViewActMenu.addAction("Logarithmic scale (log\u2090time)")
        logAct.setShortcut(Qt.Key_4)
        logAct.setToolTip(u"scale times (y-axis) down with logarithmic function: log\u2090time (a=%f) (4)" % self.VP.R.getLogRadix())
        logAct.setStatusTip(u"scale times (y-axis) down with logarithmic function: log\u2090time (a=%f) (4)" % self.VP.R.getLogRadix())
        logAct.triggered.connect(self.VP.switch_layout_to_dag_timing_log)
        dagtimingViewAct.setMenu(dagtimingViewActMenu)
        dagtimingViewActMenu.addSeparator()
        adjustAct = dagtimingViewActMenu.addAction(u"Adjust scaling factor (a) with SHIFT + mouse scrolling")
        adjustAct.setCheckable(True)
        adjustAct.setChecked(True)
        self.adjustScalingFactorEnabled = True
        dagtimingViewActMenu.addAction(u"Set exact scaling factors")
        paraprofViewAct = viewTypeMenu.addAction('Timelines with parallelism profile')
        paraprofViewAct.setShortcut(Qt.Key_5)
        paraprofViewAct.setIcon(QIcon(sysroot + '/gui/paraprof_icon.svg'))
        paraprofViewAct.setToolTip('Switch to timelines with parallelism profile (5)')
        paraprofViewAct.setStatusTip('Switch to timelines view with parallelism profile on top (5)')
        paraprofViewAct.triggered.connect(self.VP.switch_layout_to_paraprof)
        
        showhideMenu = viewMenu.addMenu('Sh&ow/Hide')
        replayAct = QAction('&Replay', self, checkable=True)
        replayAct.setShortcut('Shift+Ctrl+R')
        replayAct.setChecked(False)
        #replayAct.triggered.connect(qApp.quit)
        nodeinfoAct = QAction('&Node information', self, checkable=True)
        nodeinfoAct.setShortcut('Shift+Ctrl+N')
        nodeinfoAct.setChecked(False)
        #nodeinfoAct.triggered.connect(qApp.quit)
        showhideMenu.addAction(replayAct)
        showhideMenu.addAction(nodeinfoAct)

        zoomMenu = viewMenu.addMenu('&Zoom')
        zoomInAct = zoomMenu.addAction('Zoom In')
        zoomInAct.setShortcut('+')
        zoomInAct.triggered.connect(self.VP.do_zoom_in)
        zoomOutAct = zoomMenu.addAction('Zoom Out')
        zoomOutAct.setShortcut('-')
        zoomOutAct.triggered.connect(self.VP.do_zoom_out)
        zoomMenu.addSeparator()
        zoomFullAct = zoomMenu.addAction('Fit &Full (F)')
        zoomFullAct.setShortcut('F')
        zoomFullAct.setIcon(QIcon(sysroot + '/gui/fit_button_icon.svg'))
        zoomFullAct.setStatusTip('Fit Full (F)')
        zoomFullAct.triggered.connect(self.VP.do_zoom_fit_full)
        zoomHorAct = self.zoomHorAct = zoomMenu.addAction('Fit &Horizontally')
        zoomHorAct.setShortcut('H')
        zoomHorAct.triggered.connect(self.VP.do_zoom_fit_hor)
        zoomVerAct = zoomMenu.addAction('Fit &Vertically')
        zoomVerAct.setShortcut('V')
        zoomVerAct.triggered.connect(self.VP.do_zoom_fit_ver)

        # toolbar
        self.toolbar = self.addToolBar('Toolbar')
        self.toolbar.addAction(dagViewAct)
        self.toolbar.addAction(dagtimingViewAct)
        self.toolbar.addAction(paraprofViewAct)
        self.toolbar.addSeparator()
        self.toolbar.addAction(zoomFullAct)
        self.toolbar.addAction(expandAct)
        self.toolbar.addAction(collapseAct)
        self.toolbar.addSeparator()

        # context menu
        self.cmenu = QMenu(self)
        self.cmenu.addAction(expandAct)
        self.cmenu.addAction(collapseAct)
        self.cmenu.addSeparator()
        zoomMenu = self.cmenu.addMenu('&Zoom')
        zoomMenu.addAction(zoomFullAct)
        zoomMenu.addAction(zoomHorAct)
        zoomMenu.addAction(zoomVerAct)

        # hidden actions
        # moveUpAct = QAction(self)
        # moveUpAct.setShortcut(Qt.Key_Up)
        # moveUpAct.triggered.connect(self.VP.move_up)
        # self.addAction(moveUpAct)
        # moveDownAct = QAction(self)
        # moveDownAct.setShortcut(Qt.Key_Down)
        # moveDownAct.triggered.connect(self.VP.move_down)
        # self.addAction(moveDownAct)
        # moveLeftAct = QAction(self)
        # moveLeftAct.setShortcut(Qt.Key_Left)
        # moveLeftAct.triggered.connect(self.VP.move_left)
        # self.addAction(moveLeftAct)
        # moveRightAct = QAction(self)
        # moveRightAct.setShortcut(Qt.Key_Right)
        # moveRightAct.triggered.connect(self.VP.move_right)
        # self.addAction(moveRightAct)
        
        # central widget
        self.setCentralWidget(self.VP)
        
        # show
        self.show()

    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Up:
            self.VP.move_up()
        if e.key() == Qt.Key_Down:
            self.VP.move_down()
        if e.key() == Qt.Key_Left:
            self.VP.move_left()
        elif e.key() == Qt.Key_Right:
            self.VP.move_right()
               
    # def closeEvent(self, event):
    #     print("closeEvent handler.")
    #     reply = QMessageBox.question(self, 'Message', "Are you sure to quit?",
    #                                  QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
    #     if reply == QMessageBox.Yes:
    #         event.accept()
    #     else:
    #         event.ignore()

    def center(self):
        windowrec = self.frameGeometry()
        centerpt = QDesktopWidget().availableGeometry().center()
        windowrec.moveCenter(centerpt)
        self.move(windowrec.topLeft())

        
if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = DAGViz()
    sys.exit(app.exec_())
