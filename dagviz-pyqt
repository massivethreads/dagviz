#!/usr/bin/python3

import sys, os, random

#from PyQt5.QtGui import QIcon, QFont
#from PyQt5.QtWidgets import QApplication, QWidget, QToolTip, QPushButton
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

import sip
sysroot = os.path.dirname(os.path.realpath(sys.argv[0]))
sys.path.append(sysroot + "/sip")
import dagrenderer

GO = {
    "zoom_rate_per_time" : 0.08,   # rate per scrolling time
    "zoom_rate_per_pixel" : 0.004, # rate per scrolling pixel: 0.08 / 20
    "zoom_default_weight" : 20,    # rate in pixel unit on one default zoom
    "margin_top"    : 20,
    "margin_bottom" : 20,
    "margin_left"   : 20,
    "margin_right"  : 20,
    "moving_distance" : 25.0,      # pixels, moving distance when pressing arrow keys
    "moving_distance_rate" : 20.0, # times, multiplied rate with modifier keys (Ctrl > Alt)
    "auto_zoom_fit" : 1, # automatically zoom to fit at the beginning: 0->none, 1->full, 2->hor, 3->ver
    "scaling_radix_scrolling_rate": 0.004, # rate for adjusting scaling radix at each scrolling
}

renderers = []

class Marker(QWidget):
    def __init__(self):
        super(Marker, self).__init__()
    def enable(self):
        self.color = "red"
        self.update()
    def disable(self):
        self.color = "white"
        self.update()
    def paintEvent(self, e):
        qp = QPainter(self)
        qp.fillRect(0, 0, self.width(), self.height(), QColor(self.color))
        

class ScrollBar(QSlider):
    def __init__(self, o):
        super(ScrollBar, self).__init__(o)
        self.length = 100
        self.color = "grey"
        #self.setTracking(True)
        self.setTracking(False)
        self.valueChanged.connect(self.doValueChanged)
        self.setSingleStep(1)
        self.setPageStep(20)        
        self.resetStyle()
        
    def resetStyle(self):
        if self.orientation() == Qt.Horizontal:
            self.setStyleSheet("""
QSlider::groove:horizontal {
    border: none;
    background: white;
    height: 4px;
}
QSlider:horizontal {
    height: 4px;
    margin: 0px 0px 0px 0px;
}
QSlider::handle:horizontal {
    background: solid %s;
    width: %i px;
}
        """ % (self.color, self.length))
        else:
            self.setStyleSheet("""
QSlider::groove:vertical {
    border: none;
    background: white;
    width: 4px;
}
QSlider:vertical {
    width: 4px;
    margin: 0px 0px 0px 0px;
}
QSlider::handle:vertical {
    background: solid %s;
    height: %i px;
}
        """ % (self.color, self.length))
        
    def setLength(self, l):
        self.length = l
        self.resetStyle()

    def doValueChanged(self, v):
        #print(v)
        #print(self.value())
        None

    def adjust(self, w, d1, d2, v1, v2):
        a = 0 # min value
        b = w # max value
        p = 0 # current value
        l = w # handle's length 
        if d2 - d1 > v2 - v1:
            self.color = "black"
            left = d1
            right = d2 - (v2 - v1)
            a = 0
            b = w * (right - left) / (d2 - d1)
            p = (v1 - left) / (right - left) * (b - a)
            l = (v2 - v1) / (right - left) * (b - a)
            if p < a:
                l -= a - p
            if p > b:
                l -= p - b
        elif v2 - v1 > d2 - d1:
            self.color = "grey"
            left = v1
            right = v2 - (d2 - d1)
            a = 0
            b = w * (right - left) / (v2 - v1)
            p = (d1 - left) / (right - left) * (b - a)
            l = (d2 - d1) / (right - left) * (b - a)
            if p < a:
                l -= a - p
            if p > b:
                l -= p - b
        # else:
        #     if v1 > d1:
        #         b = (v1 - d1) / (d2 - d1) * w
        #         p = b
        #         l = w - b
        #     elif v2 < d2:
        #         l -= (d2 - v2) / (d2 - d1) * (b - a)
        if l < 3:
            l = 3
        self.setMinimum(a)
        self.setMaximum(b)
        self.setValue(p)
        self.setLength(l)
        

class Viewport(QWidget):
    def __init__(self, W, R, lt):
        super(Viewport, self).__init__()
        self.W = W
        self.R = R
        self.currentLayout = lt
        self.switch_layout_to(lt)
        # container with scroll bars
        self.verScrollBar = ScrollBar(Qt.Vertical)
        self.verScrollBar.setRange(0, 0)
        self.verScrollBar.setValue(0)
        self.verScrollBar.setLength(0)
        self.horScrollBar = ScrollBar(Qt.Horizontal)
        self.horScrollBar.setRange(0, 0)
        self.horScrollBar.setValue(0)
        self.horScrollBar.setLength(0)
        self.marker = Marker()
        self.marker.disable()
        # hbox = QHBoxLayout()
        # hbox.setContentsMargins(0, 0, 0, 0)
        # hbox.setSpacing(0)
        # hbox.addWidget(self, 1)
        # hbox.addWidget(self.verScrollBar, 0)
        # vbox = QVBoxLayout()
        # vbox.setContentsMargins(0, 0, 0, 0)
        # vbox.setSpacing(0)
        # vbox.addLayout(hbox, 1)
        # hbox = QHBoxLayout()
        # hbox.setContentsMargins(0, 0, 0, 0)
        # hbox.setSpacing(0)
        # hbox.addWidget(self.horScrollBar, 1)
        # hbox.addWidget(self.verScrollBar, 0)        
        # vbox.addLayout(hbox, 0)
        # self.containerWithScrollBars = QWidget()
        # self.containerWithScrollBars.setLayout(vbox)
        grid = QGridLayout()
        grid.setContentsMargins(0, 0, 0, 0)
        grid.setSpacing(0)
        grid.addWidget(self, 0, 0)
        grid.addWidget(self.verScrollBar, 0, 1)
        grid.addWidget(self.horScrollBar, 1, 0)
        grid.addWidget(self.marker, 1, 1)
        self.containerWithScrollBars = QWidget()
        self.containerWithScrollBars.setLayout(grid)
        
        # background color
        pal = self.palette()
        pal.setColor(QPalette.Window, Qt.white)
        self.setPalette(pal)
        self.setAutoFillBackground(True)
        self.base_x = GO["margin_left"]
        self.base_y = GO["margin_top"]
        self.x = 0.0
        self.y = 0.0
        self.pan_on = False
        self.x_mouse_pressed = 0
        self.y_mouse_pressed = 0
        self.mouseCenteredExpansion = False
        self.x_mouse = 0
        self.y_mouse = 0
        self.setMouseTracking(True)
        self.R = R
        self.zoom_ratio_x = 1.0
        self.zoom_ratio_y = 1.0
        self.width
        # node context menu
        self.node_cmenu = QMenu(self)
        self.nodeExpandAct = self.node_cmenu.addAction("E&xpand node")
        self.nodeCollapseAct = self.node_cmenu.addAction("&Collapse parent node one depth")
        self.node_cmenu.addSeparator()
        # default action when clicked
        clickedActMenu = self.node_cmenu.addMenu("&Default action when clicked")
        self.nodeClickedActGroup = QActionGroup(clickedActMenu)
        self.nodeClickedActGroup.setExclusive(True)
        self.nodeExpandActDef = clickedActMenu.addAction("E&xpand node")
        self.nodeExpandActDef.setCheckable(True)
        self.nodeClickedActGroup.addAction(self.nodeExpandActDef)
        self.nodeCollapseActDef = clickedActMenu.addAction("&Collapse parent node one depth")
        self.nodeCollapseActDef.setCheckable(True)
        self.nodeClickedActGroup.addAction(self.nodeCollapseActDef)
        self.clickedNoneActDef = clickedActMenu.addAction("&None")
        self.clickedNoneActDef.setCheckable(True)
        self.nodeClickedActGroup.addAction(self.clickedNoneActDef)
        self.nodeExpandActDef.setChecked(True)
        # default action when hovered
        hoveredActMenu = self.node_cmenu.addMenu("&Default action when hovered")
        self.nodeHoveredActGroup = QActionGroup(hoveredActMenu)
        self.nodeHoveredActGroup.setExclusive(True)
        self.nodeInfoTooltipActDef = hoveredActMenu.addAction("Show node &information tooltip")
        self.nodeInfoTooltipActDef.setCheckable(True)
        self.nodeHoveredActGroup.addAction(self.nodeInfoTooltipActDef)
        self.hoveredNoneActDef = hoveredActMenu.addAction("&None")
        self.hoveredNoneActDef.setCheckable(True)
        self.nodeHoveredActGroup.addAction(self.hoveredNoneActDef)
        self.nodeInfoTooltipActDef.setChecked(True)
        # Initial DAG expansion
        self.do_expanding_one()
        self.do_expanding_one()

    def adjustScrollBars(self):
        # DAG: d1->d2, viewport: v1->v2 in DAG space
        d1 = - self.R.left_width(self.currentLayout)
        d2 = self.R.right_width(self.currentLayout)
        v1 = self.convert_x_to_dag_space(0)
        v2 = self.convert_x_to_dag_space(self.width())
        self.horScrollBar.adjust(self.width(), d1, d2, v1, v2)
        # DAG: d1->d2, viewport: v1->v2 in DAG space
        d1 = - self.R.down_height(self.currentLayout)
        d2 = self.R.up_height(self.currentLayout)
        v1 = - self.convert_y_to_dag_space(self.height())
        v2 = - self.convert_y_to_dag_space(0)
        self.verScrollBar.adjust(self.height(), d1, d2, v1, v2)
        
    def resizeEvent(self, e):
        # adjust base_x
        old_w = e.oldSize().width()
        margin = GO["margin_left"] + GO["margin_right"]
        if old_w >= 0:
            self.base_x -= (old_w - margin) / 2.0
        self.base_x += (self.width() - margin) / 2.0

    def update(self):
        super(Viewport, self).update()

    def convert_x_to_dag_space(self, x):
        return (x - self.x - self.base_x) / self.zoom_ratio_x
    def convert_y_to_dag_space(self, y):
        return (y - self.y - self.base_y) / self.zoom_ratio_y
    def convert_x_from_dag_space(self, x):
        return x * self.zoom_ratio_x + self.x + self.base_x
    def convert_y_from_dag_space(self, y):
        return y * self.zoom_ratio_y + self.y + self.base_y
    def convert_dx_from_dag_space(self, dx):
        return dx * self.zoom_ratio_x
    def convert_dy_from_dag_space(self, dy):
        return dy * self.zoom_ratio_y
        
    def paintEvent(self, e):
        # adjusted deltas from Renderer
        Rdx = self.convert_dx_from_dag_space(self.R.getDx())
        Rdy = self.convert_dy_from_dag_space(self.R.getDy())
        self.x += Rdx
        self.y += Rdy
        # auto zoom fit
        if GO["auto_zoom_fit"] == 1:
            self.do_zoom_fit_full_auto()
        elif GO["auto_zoom_fit"] == 2:
            self.do_zoom_fit_hor_auto()
        elif GO["auto_zoom_fit"] == 3:
            self.do_zoom_fit_ver_auto()
        qp = QPainter(self)
        qp.translate(self.base_x, self.base_y)
        qp.translate(self.x, self.y)
        qp.scale(self.zoom_ratio_x, self.zoom_ratio_y)
        if self.R is not None:
            if (self.mouseCenteredExpansion):
                self.R.draw(sip.unwrapinstance(qp),
                            self.convert_x_to_dag_space(self.x_mouse),
                            self.convert_y_to_dag_space(self.y_mouse))
            else:
                self.R.draw(sip.unwrapinstance(qp))
        # adjust scrollbars
        self.adjustScrollBars()

    def do_moving(self, dx, dy):
        self.x = self.x + dx
        self.y = self.y + dy
        GO["auto_zoom_fit"] = False
        self.update()

    def do_zooming(self, x, y, weight):
        if weight != 0:
            new_zx = self.zoom_ratio_x
            new_zy = self.zoom_ratio_y
            factor = 1 + GO["zoom_rate_per_pixel"] * abs(weight)
            if weight > 0:
                new_zx *= factor
                new_zy *= factor
            else:
                new_zx /= factor
                new_zy /= factor
            x_dag = self.convert_x_to_dag_space(x)
            y_dag = self.convert_y_to_dag_space(y)
            self.zoom_ratio_x = new_zx
            self.zoom_ratio_y = new_zy
            new_x = self.convert_x_from_dag_space(x_dag)
            new_y = self.convert_y_from_dag_space(y_dag)
            dx = new_x - x
            dy = new_y - y
            self.x -= dx
            self.y -= dy
            GO["auto_zoom_fit"] = False
            self.update()
        
    def change_dag_scaling_factor(self, weight):
        if weight != 0:
            if self.currentLayout == self.R.LAYOUT_TYPE_2 or self.currentLayout == self.R.LAYOUT_TYPE_3 or self.currentLayout == self.R.LAYOUT_TYPE_4:
                if self.currentLayout == self.R.LAYOUT_TYPE_2:
                    radix = self.R.getLinearRadix();
                elif self.currentLayout == self.R.LAYOUT_TYPE_3:
                    radix = self.R.getPowerRadix();
                elif self.currentLayout == self.R.LAYOUT_TYPE_4:
                    radix = self.R.getLogRadix();
                factor = 1 + GO["scaling_radix_scrolling_rate"] * abs(weight)
                if weight > 0:
                    radix *= factor
                else:
                    radix /= factor
                if self.currentLayout == self.R.LAYOUT_TYPE_2:
                    self.R.setLinearRadix(radix);
                elif self.currentLayout == self.R.LAYOUT_TYPE_3:
                    self.R.setPowerRadix(radix);
                elif self.currentLayout == self.R.LAYOUT_TYPE_4:
                    self.R.setLogRadix(radix);
                self.R.layout(self.currentLayout)
                self.update()
        
    def wheelEvent(self, e):
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            # moving
            self.do_moving(e.pixelDelta().x(), e.pixelDelta().y())
        elif mod == Qt.ShiftModifier:
            # scrolling scaling factor
            if self.W.adjustScalingFactorEnabled:
                weight = e.pixelDelta().y()
                self.change_dag_scaling_factor(weight)
        else:
            # zooming
            weight = e.pixelDelta().y()
            self.do_zooming(e.x(), e.y(), weight)
        self.update()

    def mousePressEvent(self, e):
        # only detect LeftButton (RightButton triggers context menus)
        if e.button() == Qt.LeftButton:
            # pan 
            self.x_mouse_pressed = e.x()
            self.y_mouse_pressed = e.y()
            self.pan_on = True
    def mouseReleaseEvent(self, e):
        # only detect LeftButton (RightButton triggers context menus)
        if e.button() == Qt.LeftButton:
            # pan
            self.pan_on = False
            # node clicked
            checkedAction = self.nodeClickedActGroup.checkedAction()
            if checkedAction != self.clickedNoneActDef:            
                x_dag = self.convert_x_to_dag_space(e.x())
                y_dag = self.convert_y_to_dag_space(e.y())
                node = self.R.find_node(x_dag, y_dag, self.currentLayout)
                if node is not None:
                    if checkedAction == self.nodeExpandActDef:
                        self.R.do_expanding_one_r(node)
                    elif checkedAction == self.nodeCollapseActDef:
                        self.R.do_collapsing_parent(node)
                    if self.R.animationOn == 0:
                        self.R.layout()
                        self.update()                    

    def enterEvent(self, e):
        #print("mouse enters")
        self.mouseCenteredExpansion = True
        None
        
    def leaveEvent(self, e):
        #print("mouse leaves")
        self.mouseCenteredExpansion = False
        None
        
    def mouseMoveEvent(self, e):
        self.x_mouse = e.x()
        self.y_mouse = e.y()
        if self.pan_on:
            self.x += e.x() - self.x_mouse_pressed
            self.y += e.y() - self.y_mouse_pressed
            self.x_mouse_pressed = e.x()
            self.y_mouse_pressed = e.y()
            GO["auto_zoom_fit"] = False
            self.update()
        else:
            # node hovered
            checkedAction = self.nodeHoveredActGroup.checkedAction()
            if checkedAction != self.hoveredNoneActDef:
                x_dag = self.convert_x_to_dag_space(e.x())
                y_dag = self.convert_y_to_dag_space(e.y())
                node = self.R.find_node(x_dag, y_dag, self.currentLayout)
                if node is not None:
                    if checkedAction == self.nodeInfoTooltipActDef:
                        info_dict = self.R.get_dag_node_info(node)
                        info_str = self.get_node_info_string(info_dict)
                        QToolTip.showText(e.globalPos(), info_str, self, QRect(), 30000)
                else:
                    if checkedAction == self.nodeInfoTooltipActDef:
                        QToolTip.showText(e.globalPos(), None, self)

    def get_node_info_string(self, d):
        s = ("Worker %i, CPU %i, node kind %i\n"
             "  t_1 (work): %i\n"
             "t_inf (span): %i\n"
             "earliest start time: %i\n"
             "    first ready time: %i\n"
             "       last start time: %i\n"
             "start: t=%i, worker %i, CPU %i (%s:%i)\n"
             "  end: t=%i, worker %i, CPU %i (%s:%i)\n"
             "counters=%s") % (
                 d["worker"], d["cpu"], d["kind"],
                 d["t_1"], d["t_inf"],
                 d["est"], d["first_ready_t"], d["last_start_t"],
                 d["start"][0], d["start"][1], d["start"][2], d["start"][3], d["start"][4],
                 d["end"][0], d["end"][1], d["end"][2], d["end"][3], d["end"][4],
                 d["counters"])
        return s

    def move_up(self):
        dx = 0.0
        dy = GO["moving_distance"]
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
    def move_down(self):
        dx = 0.0
        dy = - GO["moving_distance"]
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
    def move_left(self):
        dx = GO["moving_distance"]
        dy = 0.0
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
    def move_right(self):
        dx = - GO["moving_distance"]
        dy = 0.0
        rate = 1.0
        mod = QApplication.keyboardModifiers()
        if mod == Qt.ControlModifier:
            rate *= GO["moving_distance_rate"]
        elif mod == Qt.AltModifier:
            rate /= GO["moving_distance"] # 1 pixel
        self.do_moving(dx*rate, dy*rate)
        
    def do_zoom_in(self):
        self.do_zooming(self.width() / 2, self.height() / 2, GO["zoom_default_weight"])
        
    def do_zoom_out(self):
        self.do_zooming(self.width() / 2, self.height() / 2, - GO["zoom_default_weight"])

    def get_zoom_fit_hor_attributes(self):
        x = 0.0
        y = 0.0
        z = 1.0
        if self.R == None:
            return x,y,z
        w1 = self.R.width(self.currentLayout)
        w2 = self.width() - GO["margin_left"] - GO["margin_right"]
        if w1 > w2:
            z = w2 / w1
        x -= z * (self.R.right_width(self.currentLayout) - self.R.left_width(self.currentLayout)) / 2
        return x,y,z
    def do_zoom_fit_hor_auto(self):
        x,y,z = self.get_zoom_fit_hor_attributes()
        self.x = x
        self.y = y
        self.zoom_ratio_x = z
        self.zoom_ratio_y = z
    def do_zoom_fit_hor(self):
        self.do_zoom_fit_hor_auto()
        GO["auto_zoom_fit"] = 2
        self.update()
            
    def get_zoom_fit_ver_attributes(self):
        x = 0.0
        y = 0.0
        z = 1.0
        if self.R == None:
            return x,y,z
        h1 = self.R.height(self.currentLayout)
        h2 = self.height() - GO["margin_top"] - GO["margin_bottom"]
        if h1 > h2:
            z = h2 / h1
        x -= z * (self.R.right_width(self.currentLayout) - self.R.left_width(self.currentLayout)) / 2
        return x,y,z
    def do_zoom_fit_ver_auto(self):
        x,y,z = self.get_zoom_fit_ver_attributes()
        self.x = x
        self.y = y
        self.zoom_ratio_x = z
        self.zoom_ratio_y = z
    def do_zoom_fit_ver(self):
        self.do_zoom_fit_ver_auto()
        GO["auto_zoom_fit"] = 3
        self.update()
        
    def do_zoom_fit_full_auto(self):
        x1,y1,z1 = self.get_zoom_fit_hor_attributes()
        x2,y2,z2 = self.get_zoom_fit_ver_attributes()
        if z1 < z2:
            self.x = x1
            self.y = y1
            self.zoom_ratio_x = z1
            self.zoom_ratio_y = z1
        else:
            self.x = x2
            self.y = y2
            self.zoom_ratio_x = z2
            self.zoom_ratio_y = z2
    def do_zoom_fit_full(self):
        self.do_zoom_fit_full_auto()
        GO["auto_zoom_fit"] = 1
        self.update()
        
    def do_expanding_one(self):
        if self.R is not None:
            self.R.do_expanding_one()
            if self.R.animationOn == 0:
                self.R.layout()
                self.update()
    
    def do_collapsing_one(self):
        if self.R is not None:
            self.R.do_collapsing_one()
            if self.R.animationOn == 0:
                self.R.layout()
                self.update()

    def contextMenuEvent(self, e):
        x_dag = self.convert_x_to_dag_space(e.x())
        y_dag = self.convert_y_to_dag_space(e.y())
        node = self.R.find_node(x_dag, y_dag, self.currentLayout)
        if node is not None:
            cmenu = self.node_cmenu
            action = cmenu.exec_(self.mapToGlobal(e.pos()))
            if action == self.nodeExpandAct:
                self.R.do_expanding_one_r(node)
            elif action == self.nodeCollapseAct:
                self.R.do_collapsing_parent(node)
            if self.R.animationOn == 0:
                self.R.layout()
                self.update()
        else:
            cmenu = self.W.cmenu
            action = cmenu.exec_(self.mapToGlobal(e.pos()))

    def switch_layout_to(self, lt):
        self.R.removeViewport(sip.unwrapinstance(self))
        self.R.addViewport(sip.unwrapinstance(self), lt)
        self.currentLayout = lt
        self.R.layout(lt)
        self.update()
               
        
class DAGViz(QMainWindow):
    def __init__(self):
        super(DAGViz, self).__init__()
        # DAGs
        for arg in sys.argv[1:]:
            R = dagrenderer.DAGRenderer()
            R.setDAG(arg)
            renderers.append(R)
        R = renderers[0]
        self.viewports = []
        V = Viewport(self, R, R.LAYOUT_TYPE_1)
        self.viewports.append(V)
        V = Viewport(self, R, R.LAYOUT_TYPE_2)
        self.viewports.append(V)
        V = Viewport(self, R, R.LAYOUT_TYPE_3)
        self.viewports.append(V)
        self.V = None
        # central widget
        hbox = QHBoxLayout()
        hbox.setContentsMargins(0, 0, 0, 0)
        hbox.setSpacing(5)
        hbox.addWidget(self.viewports[0].containerWithScrollBars)
        vbox = QVBoxLayout()
        vbox.setContentsMargins(0, 0, 0, 0)
        vbox.setSpacing(5)
        vbox.addWidget(self.viewports[1].containerWithScrollBars)
        vbox.addWidget(self.viewports[2].containerWithScrollBars)
        hbox.addLayout(vbox)
        self.centralWidget = QWidget()
        self.centralWidget.setLayout(hbox)
        # UI
        self.setFocusedViewport(self.viewports[0])
        self.initUI()
        
    def initUI(self):
        # main window
        self.setGeometry(0, 0, 1100, 800)
        self.center()
        self.setWindowTitle('DAGViz')
        self.setWindowIcon(QIcon(sysroot + '/gui/dagviz_icon.svg'))

        # status bar
        self.statusBar().showMessage('Tips: scroll to zoom, Ctrl and scroll (or double click and drag) to move')

        # menu bar
        menubar = self.menuBar()
        #menubar.setNativeMenuBar(False)
        fileMenu = menubar.addMenu('&File')
        editMenu = menubar.addMenu('&Edit')
        viewMenu = menubar.addMenu('&View')

        # file
        exitAct = QAction(QIcon(sysroot + '/gui/exit.svg'), '&Exit', self)
        exitAct.setShortcut('Ctrl+Q')
        exitAct.setStatusTip('Exit application')
        exitAct.triggered.connect(qApp.quit)
        fileMenu.addAction(exitAct)

        # edit
        expandAct = QAction(QIcon(sysroot + '/gui/plus_button_icon.svg'), 'E&xpand DAG one depth (X)', self)
        expandAct.setShortcut('X')
        expandAct.setStatusTip('Expand DAG one depth (X)')
        expandAct.triggered.connect(self.onExpandAct)
        editMenu.addAction(expandAct)
        collapseAct = QAction(QIcon(sysroot + '/gui/minus_button_icon.svg'), '&Collapse DAG one depth (C)', self)
        collapseAct.setShortcut('C')
        collapseAct.setStatusTip('Collapse DAG one depth (C)')
        collapseAct.triggered.connect(self.onCollapseAct)
        editMenu.addAction(collapseAct)

        # view
        viewTypeMenu = viewMenu.addMenu('&View types')
        dagViewAct = viewTypeMenu.addAction('DAG')
        dagViewAct.setShortcut(Qt.Key_1)
        dagViewAct.setIcon(QIcon(sysroot + '/gui/dag_icon.svg'))
        dagViewAct.setToolTip('Switch to basic DAG (1)')
        dagViewAct.setStatusTip('Switch to basic DAG view (1)')
        dagViewAct.triggered.connect(self.onDagViewAct)
        dagtimingViewAct = viewTypeMenu.addAction('DAG with timing')
        dagtimingViewAct.setIcon(QIcon(sysroot + '/gui/dag_boxes_icon.svg'))
        dagtimingViewAct.setToolTip('Switch to DAG with timing (2)')
        dagtimingViewAct.setStatusTip('Switch to DAG with timing on y-axis (2)')
        dagtimingViewAct.triggered.connect(self.onDagLinearViewAct)
        dagtimingViewActMenu = QMenu(self)
        linearAct = dagtimingViewActMenu.addAction(u"Linear scale (time\u00F7a)")
        linearAct.setShortcut(Qt.Key_2)
        linearAct.setToolTip(u"scale times (y-axis) down with linear function: time\u00F7a (2)")
        linearAct.setStatusTip(u"scale times (y-axis) down with linear function: time\u00F7a (2)")
        linearAct.triggered.connect(self.onDagLinearViewAct)
        powerAct = dagtimingViewActMenu.addAction(u"Power scale (time\u1d43)")
        powerAct.setShortcut(Qt.Key_3)
        powerAct.setToolTip(u"scale times (y-axis) down with power function: time\u1d43 (3)")
        powerAct.setStatusTip(u"scale times (y-axis) down with powerfunction: time\u1d43 (3)")
        powerAct.triggered.connect(self.onDagPowerViewAct)
        logAct = dagtimingViewActMenu.addAction("Logarithmic scale (log\u2090time)")
        logAct.setShortcut(Qt.Key_4)
        logAct.setToolTip(u"scale times (y-axis) down with logarithmic function: log\u2090time (4)")
        logAct.setStatusTip(u"scale times (y-axis) down with logarithmic function: log\u2090time (4)")
        logAct.triggered.connect(self.onDagLogViewAct)
        dagtimingViewAct.setMenu(dagtimingViewActMenu)
        dagtimingViewActMenu.addSeparator()
        adjustAct = dagtimingViewActMenu.addAction(u"Adjust scaling factor (a) with SHIFT + mouse scrolling")
        adjustAct.setCheckable(True)
        adjustAct.setChecked(True)
        self.adjustScalingFactorEnabled = True
        dagtimingViewActMenu.addAction(u"Set exact scaling factors")
        paraprofViewAct = viewTypeMenu.addAction('Timelines with parallelism profile')
        paraprofViewAct.setShortcut(Qt.Key_5)
        paraprofViewAct.setIcon(QIcon(sysroot + '/gui/paraprof_icon.svg'))
        paraprofViewAct.setToolTip('Switch to timelines with parallelism profile (5)')
        paraprofViewAct.setStatusTip('Switch to timelines view with parallelism profile on top (5)')
        paraprofViewAct.triggered.connect(self.onDagParaprofViewAct)
        
        # showhideMenu = viewMenu.addMenu('Sh&ow/Hide')
        # replayAct = QAction('&Replay', self, checkable=True)
        # replayAct.setShortcut('Shift+Ctrl+R')
        # replayAct.setChecked(False)
        # #replayAct.triggered.connect(qApp.quit)
        # nodeinfoAct = QAction('&Node information', self, checkable=True)
        # nodeinfoAct.setShortcut('Shift+Ctrl+N')
        # nodeinfoAct.setChecked(False)
        # #nodeinfoAct.triggered.connect(qApp.quit)
        # showhideMenu.addAction(replayAct)
        # showhideMenu.addAction(nodeinfoAct)

        zoomMenu = viewMenu.addMenu('&Zoom')
        zoomInAct = zoomMenu.addAction('Zoom In')
        zoomInAct.setShortcut('+')
        zoomInAct.triggered.connect(self.onZoomInAct)
        zoomOutAct = zoomMenu.addAction('Zoom Out')
        zoomOutAct.setShortcut('-')
        zoomOutAct.triggered.connect(self.onZoomOutAct)
        zoomMenu.addSeparator()
        zoomFullAct = zoomMenu.addAction('Fit &Full (F)')
        zoomFullAct.setShortcut('F')
        zoomFullAct.setIcon(QIcon(sysroot + '/gui/fit_button_icon.svg'))
        zoomFullAct.setStatusTip('Fit Full (F)')
        zoomFullAct.triggered.connect(self.onZoomFullAct)
        zoomHorAct = self.zoomHorAct = zoomMenu.addAction('Fit &Horizontally')
        zoomHorAct.setShortcut('H')
        zoomHorAct.triggered.connect(self.onZoomHorAct)
        zoomVerAct = zoomMenu.addAction('Fit &Vertically')
        zoomVerAct.setShortcut('V')
        zoomVerAct.triggered.connect(self.onZoomVerAct)

        viewMenu.addSeparator()
        switchViewportAct = viewMenu.addAction("Switch focused viewport")
        switchViewportAct.setShortcut('Ctrl+Tab')
        switchViewportAct.triggered.connect(self.switchFocusedViewport)

        # toolbar
        self.toolbar = self.addToolBar('Toolbar')
        self.toolbar.addAction(dagViewAct)
        self.toolbar.addAction(dagtimingViewAct)
        self.toolbar.addAction(paraprofViewAct)
        self.toolbar.addSeparator()
        self.toolbar.addAction(zoomFullAct)
        self.toolbar.addAction(expandAct)
        self.toolbar.addAction(collapseAct)
        self.toolbar.addSeparator()

        # context menu
        self.cmenu = QMenu(self)
        self.cmenu.addAction(expandAct)
        self.cmenu.addAction(collapseAct)
        self.cmenu.addSeparator()
        zoomMenu = self.cmenu.addMenu('&Zoom')
        zoomMenu.addAction(zoomFullAct)
        zoomMenu.addAction(zoomHorAct)
        zoomMenu.addAction(zoomVerAct)

        # hidden actions
        moveUpAct = QAction(self)
        moveUpAct.setShortcut(Qt.Key_Up)
        moveUpAct.triggered.connect(self.onMoveUpAct)
        self.addAction(moveUpAct)
        moveDownAct = QAction(self)
        moveDownAct.setShortcut(Qt.Key_Down)
        moveDownAct.triggered.connect(self.onMoveDownAct)
        self.addAction(moveDownAct)
        moveLeftAct = QAction(self)
        moveLeftAct.setShortcut(Qt.Key_Left)
        moveLeftAct.triggered.connect(self.onMoveLeftAct)
        self.addAction(moveLeftAct)
        moveRightAct = QAction(self)
        moveRightAct.setShortcut(Qt.Key_Right)
        moveRightAct.triggered.connect(self.onMoveRightAct)
        self.addAction(moveRightAct)
        
        # central widget
        self.setCentralWidget(self.centralWidget)
        
        # show
        self.show()

    def setFocusedViewport(self, V):
        if V in self.viewports:
            if self.V is not None:
                self.V.marker.disable()
            if V is not None:
                self.V = V
                self.V.marker.enable()

    def switchFocusedViewport(self):
        V = self.V
        if V is None:
            V = self.viewports[0]
        else:
            i = self.viewports.index(V)
            i = (i + 1) % len(self.viewports)
            V = self.viewports[i]
        self.setFocusedViewport(V)
        
    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Up:
            self.V.move_up()
        if e.key() == Qt.Key_Down:
            self.V.move_down()
        if e.key() == Qt.Key_Left:
            self.V.move_left()
        elif e.key() == Qt.Key_Right:
            self.V.move_right()

    def onExpandAct(self, e):
        self.V.do_expanding_one()
    def onCollapseAct(self, e):
        self.V.do_collapsing_one()
        
    def onDagViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_1)
    def onDagLinearViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_2)
    def onDagPowerViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_3)
    def onDagLogViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_4)
    def onDagParaprofViewAct(self):
        self.V.switch_layout_to(dagrenderer.DAGRenderer.LAYOUT_TYPE_5)
        
    def onZoomInAct(self):
        self.V.do_zoom_in()
    def onZoomOutAct(self):
        self.V.do_zoom_out()
    def onZoomFullAct(self):
        self.V.do_zoom_fit_full()
    def onZoomHorAct(self):
        self.V.do_zoom_fit_hor()
    def onZoomVerAct(self):
        self.V.do_zoom_fit_ver()

    def onMoveUpAct(self):
        self.V.move_up()
    def onMoveDownAct(self):
        self.V.move_down()
    def onMoveLeftAct(self):
        self.V.move_left()
    def onMoveRightAct(self):
        self.V.move_right()

    # def closeEvent(self, event):
    #     print("closeEvent handler.")
    #     reply = QMessageBox.question(self, 'Message', "Are you sure to quit?",
    #                                  QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
    #     if reply == QMessageBox.Yes:
    #         event.accept()
    #     else:
    #         event.ignore()

    def center(self):
        windowrec = self.frameGeometry()
        centerpt = QDesktopWidget().availableGeometry().center()
        windowrec.moveCenter(centerpt)
        self.move(windowrec.topLeft())

        
if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = DAGViz()
    sys.exit(app.exec_())
