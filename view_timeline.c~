#include "dagviz.h"

/*-----------Timeline layout functions----------------------*/

static void dv_layout_timeline_node(dv_dag_node_t *node) {
  /* Calculate inward */
  int is_single_node = 1;
  switch (node->pi->info.kind) {
  case dr_dag_node_kind_wait_tasks:
  case dr_dag_node_kind_end_task:
  case dr_dag_node_kind_create_task:
    break;
  case dr_dag_node_kind_section:
  case dr_dag_node_kind_task:
    if (dv_is_union(node))
      is_single_node = 0;
    break;
  default:
    dv_check(0);
    break;
  }
  // node's inward
  node->lw = dv_layout_calculate_hsize(node);
  node->rw = dv_layout_calculate_hsize(node);
  node->dw = dv_layout_calculate_vresize(node->pi->info.end.t - G->bt) - dv_layout_calculate_vresize(node->pi->info.start.t - G->bt);
  // node's outward
  int worker = node->pi->info.worker;
  node->x = DV_RADIUS + worker * (2 * DV_RADIUS + DV_HDIS);
  node->y = dv_layout_calculate_vresize(node->pi->info.start.t - G->bt);
  if (!is_single_node) {
    // Recursive call
    if (!dv_is_shrinked(node))
      dv_layout_timeline_node(node->head);
  }
    
  /* Calculate link-along */
  int n_links = dv_llist_size(node->links);
  dv_dag_node_t * u; // linked node 1
  dv_dag_node_t * v; // linked node 2
  double time_gap, gap, ugap, vgap;
  switch (n_links) {
  case 0:
    break;
  case 1:
    u = (dv_dag_node_t *) node->links->top->item;
    // Recursive call
    dv_layout_timeline_node(u);
    break;
  case 2:
    u = (dv_dag_node_t *) node->links->top->item; // cont node
    v = (dv_dag_node_t *) node->links->top->next->item; // task node
    // Recursive call
    dv_layout_timeline_node(u);
    dv_layout_timeline_node(v);
    break;
  default:
    dv_check(0);
    break;
  }
  
}

void dv_layout_timeline_dvdag(dv_dag_t *G) {

  // Absolute coord
  dv_layout_timeline_node(G->rt);

  // Check
  //print_layout(G);  

}

/*-----------end of Timeline layout functions----------------------*/


